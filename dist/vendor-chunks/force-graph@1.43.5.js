"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/force-graph@1.43.5";
exports.ids = ["vendor-chunks/force-graph@1.43.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/force-graph@1.43.5/node_modules/force-graph/dist/force-graph.mjs":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/force-graph@1.43.5/node_modules/force-graph/dist/force-graph.mjs ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ forceGraph)\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/.pnpm/d3-zoom@3.0.0/node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/.pnpm/d3-drag@3.0.0/node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/min.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/max.js\");\n/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lodash-es */ \"(ssr)/./node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/throttle.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tweenjs/tween.js */ \"(ssr)/./node_modules/.pnpm/@tweenjs+tween.js@23.1.1/node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n/* harmony import */ var kapsule__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! kapsule */ \"(ssr)/./node_modules/.pnpm/kapsule@1.14.5/node_modules/kapsule/dist/kapsule.mjs\");\n/* harmony import */ var accessor_fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/.pnpm/accessor-fn@1.5.0/node_modules/accessor-fn/dist/accessor-fn.mjs\");\n/* harmony import */ var canvas_color_tracker__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! canvas-color-tracker */ \"(ssr)/./node_modules/.pnpm/canvas-color-tracker@1.2.1/node_modules/canvas-color-tracker/dist/canvas-color-tracker.mjs\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/simulation.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/link.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/manyBody.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/center.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/.pnpm/d3-force-3d@3.0.5/node_modules/d3-force-3d/src/radial.js\");\n/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bezier-js */ \"(ssr)/./node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/bezier.js\");\n/* harmony import */ var index_array_by__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! index-array-by */ \"(ssr)/./node_modules/.pnpm/index-array-by@1.4.1/node_modules/index-array-by/dist/index-array-by.mjs\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/ordinal.js\");\n/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale-chromatic */ \"(ssr)/./node_modules/.pnpm/d3-scale-chromatic@3.1.0/node_modules/d3-scale-chromatic/src/categorical/Paired.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".force-graph-container canvas {\\n  display: block;\\n  user-select: none;\\n  outline: none;\\n  -webkit-tap-highlight-color: transparent;\\n}\\n\\n.force-graph-container .graph-tooltip {\\n  position: absolute;\\n  top: 0;\\n  font-family: sans-serif;\\n  font-size: 16px;\\n  padding: 4px;\\n  border-radius: 3px;\\n  color: #eee;\\n  background: rgba(0,0,0,0.65);\\n  visibility: hidden; /* by default */\\n}\\n\\n.force-graph-container .clickable {\\n  cursor: pointer;\\n}\\n\\n.force-graph-container .grabbable {\\n  cursor: move;\\n  cursor: grab;\\n  cursor: -moz-grab;\\n  cursor: -webkit-grab;\\n}\\n\\n.force-graph-container .grabbable:active {\\n  cursor: grabbing;\\n  cursor: -moz-grabbing;\\n  cursor: -webkit-grabbing;\\n}\\n\";\nstyleInject(css_248z);\n\nfunction _construct(t, e, r) {\n  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && _setPrototypeOf(p, r.prototype), p;\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar autoColorScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n\n// Autoset attribute colorField by colorByAccessor property\n// If an object has already a color, don't set it\n// Objects can be nodes or links\nfunction autoColorObjects(objects, colorByAccessor, colorField) {\n  if (!colorByAccessor || typeof colorField !== 'string') return;\n  objects.filter(function (obj) {\n    return !obj[colorField];\n  }).forEach(function (obj) {\n    obj[colorField] = autoColorScale(colorByAccessor(obj));\n  });\n}\n\nfunction getDagDepths (_ref, idAccessor) {\n  var nodes = _ref.nodes,\n    links = _ref.links;\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$nodeFilter = _ref2.nodeFilter,\n    nodeFilter = _ref2$nodeFilter === void 0 ? function () {\n      return true;\n    } : _ref2$nodeFilter,\n    _ref2$onLoopError = _ref2.onLoopError,\n    onLoopError = _ref2$onLoopError === void 0 ? function (loopIds) {\n      throw \"Invalid DAG structure! Found cycle in node path: \".concat(loopIds.join(' -> '), \".\");\n    } : _ref2$onLoopError;\n  // linked graph\n  var graph = {};\n  nodes.forEach(function (node) {\n    return graph[idAccessor(node)] = {\n      data: node,\n      out: [],\n      depth: -1,\n      skip: !nodeFilter(node)\n    };\n  });\n  links.forEach(function (_ref3) {\n    var source = _ref3.source,\n      target = _ref3.target;\n    var sourceId = getNodeId(source);\n    var targetId = getNodeId(target);\n    if (!graph.hasOwnProperty(sourceId)) throw \"Missing source node with id: \".concat(sourceId);\n    if (!graph.hasOwnProperty(targetId)) throw \"Missing target node with id: \".concat(targetId);\n    var sourceNode = graph[sourceId];\n    var targetNode = graph[targetId];\n    sourceNode.out.push(targetNode);\n    function getNodeId(node) {\n      return _typeof(node) === 'object' ? idAccessor(node) : node;\n    }\n  });\n  var foundLoops = [];\n  traverse(Object.values(graph));\n  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      node = _ref5[1];\n    return !node.skip;\n  }).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      id = _ref7[0],\n      node = _ref7[1];\n    return _defineProperty({}, id, node.depth);\n  }))));\n  return nodeDepths;\n  function traverse(nodes) {\n    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var _loop = function _loop() {\n      var node = nodes[i];\n      if (nodeStack.indexOf(node) !== -1) {\n        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {\n          return idAccessor(d.data);\n        });\n        if (!foundLoops.some(function (foundLoop) {\n          return foundLoop.length === loop.length && foundLoop.every(function (id, idx) {\n            return id === loop[idx];\n          });\n        })) {\n          foundLoops.push(loop);\n          onLoopError(loop);\n        }\n        return 1; // continue\n      }\n      if (currentDepth > node.depth) {\n        // Don't unnecessarily revisit chunks of the graph\n        node.depth = currentDepth;\n        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));\n      }\n    };\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      if (_loop()) continue;\n    }\n  }\n}\n\n//\n\nvar DAG_LEVEL_NODE_RATIO = 2;\n\n// whenever styling props are changed that require a canvas redraw\nvar notifyRedraw = function notifyRedraw(_, state) {\n  return state.onNeedsRedraw && state.onNeedsRedraw();\n};\nvar updDataPhotons = function updDataPhotons(_, state) {\n  if (!state.isShadow) {\n    // Add photon particles\n    var linkParticlesAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n    state.graphData.links.forEach(function (link) {\n      var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));\n      if (numPhotons) {\n        link.__photons = _toConsumableArray(Array(numPhotons)).map(function () {\n          return {};\n        });\n      } else {\n        delete link.__photons;\n      }\n    });\n  }\n};\nvar CanvasForceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n  props: {\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(_, state) {\n        state.engineRunning = false; // Pause simulation\n        updDataPhotons(_, state);\n      }\n    },\n    dagMode: {\n      onChange: function onChange(dagMode, state) {\n        // td, bu, lr, rl, radialin, radialout\n        !dagMode && (state.graphData.nodes || []).forEach(function (n) {\n          return n.fx = n.fy = undefined;\n        }); // unfix nodes when disabling dag mode\n      }\n    },\n    dagLevelDistance: {},\n    dagNodeFilter: {\n      \"default\": function _default(node) {\n        return true;\n      }\n    },\n    onDagError: {\n      triggerUpdate: false\n    },\n    nodeRelSize: {\n      \"default\": 4,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // area per val unit\n    nodeId: {\n      \"default\": 'id'\n    },\n    nodeVal: {\n      \"default\": 'val',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeAutoColorBy: {},\n    nodeCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkSource: {\n      \"default\": 'source'\n    },\n    linkTarget: {\n      \"default\": 'target'\n    },\n    linkVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkAutoColorBy: {},\n    linkLineDash: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkWidth: {\n      \"default\": 1,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCurvature: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowLength: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowColor: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowRelPos: {\n      \"default\": 0.5,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalParticles: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: updDataPhotons\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      \"default\": 0.01,\n      triggerUpdate: false\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleWidth: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    linkDirectionalParticleColor: {\n      triggerUpdate: false\n    },\n    globalScale: {\n      \"default\": 1,\n      triggerUpdate: false\n    },\n    d3AlphaMin: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    d3AlphaDecay: {\n      \"default\": 0.0228,\n      triggerUpdate: false,\n      onChange: function onChange(alphaDecay, state) {\n        state.forceLayout.alphaDecay(alphaDecay);\n      }\n    },\n    d3AlphaTarget: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: function onChange(alphaTarget, state) {\n        state.forceLayout.alphaTarget(alphaTarget);\n      }\n    },\n    d3VelocityDecay: {\n      \"default\": 0.4,\n      triggerUpdate: false,\n      onChange: function onChange(velocityDecay, state) {\n        state.forceLayout.velocityDecay(velocityDecay);\n      }\n    },\n    warmupTicks: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      \"default\": Infinity,\n      triggerUpdate: false\n    },\n    cooldownTime: {\n      \"default\": 15000,\n      triggerUpdate: false\n    },\n    // ms\n    onUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineTick: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineStop: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNeedsRedraw: {\n      triggerUpdate: false\n    },\n    isShadow: {\n      \"default\": false,\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    // Expose d3 forces for external manipulation\n    d3Force: function d3Force(state, forceName, forceFn) {\n      if (forceFn === undefined) {\n        return state.forceLayout.force(forceName); // Force getter\n      }\n      state.forceLayout.force(forceName, forceFn); // Force setter\n      return this;\n    },\n    d3ReheatSimulation: function d3ReheatSimulation(state) {\n      state.forceLayout.alpha(1);\n      this.resetCountdown();\n      return this;\n    },\n    // reset cooldown state\n    resetCountdown: function resetCountdown(state) {\n      state.cntTicks = 0;\n      state.startTickTime = new Date();\n      state.engineRunning = true;\n      return this;\n    },\n    isEngineRunning: function isEngineRunning(state) {\n      return !!state.engineRunning;\n    },\n    tickFrame: function tickFrame(state) {\n      !state.isShadow && layoutTick();\n      paintLinks();\n      !state.isShadow && paintArrows();\n      !state.isShadow && paintPhotons();\n      paintNodes();\n      return this;\n\n      //\n\n      function layoutTick() {\n        if (state.engineRunning) {\n          if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime || state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin) {\n            state.engineRunning = false; // Stop ticking graph\n            state.onEngineStop();\n          } else {\n            state.forceLayout.tick(); // Tick it\n            state.onEngineTick();\n          }\n        }\n      }\n      function paintNodes() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVisibility);\n        var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeColor);\n        var getNodeCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow / state.globalScale;\n        var visibleNodes = state.graphData.nodes.filter(getVisibility);\n        ctx.save();\n        visibleNodes.forEach(function (node) {\n          var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);\n          if (state.nodeCanvasObject && (nodeCanvasObjectMode === 'before' || nodeCanvasObjectMode === 'replace')) {\n            // Custom node before/replace paint\n            state.nodeCanvasObject(node, ctx, state.globalScale);\n            if (nodeCanvasObjectMode === 'replace') {\n              ctx.restore();\n              return;\n            }\n          }\n\n          // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n          var r = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;\n          ctx.beginPath();\n          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);\n          ctx.fillStyle = getColor(node) || 'rgba(31, 120, 180, 0.92)';\n          ctx.fill();\n          if (state.nodeCanvasObject && nodeCanvasObjectMode === 'after') {\n            // Custom node after paint\n            state.nodeCanvasObject(node, state.ctx, state.globalScale);\n          }\n        });\n        ctx.restore();\n      }\n      function paintLinks() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkColor);\n        var getWidth = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth);\n        var getLineDash = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkLineDash);\n        var getCurvature = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCurvature);\n        var getLinkCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider lines by 2px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow * 2;\n        var visibleLinks = state.graphData.links.filter(getVisibility);\n        visibleLinks.forEach(calcLinkControlPoints); // calculate curvature control points for all visible links\n\n        var beforeCustomLinks = [],\n          afterCustomLinks = [],\n          defaultPaintLinks = visibleLinks;\n        if (state.linkCanvasObject) {\n          var replaceCustomLinks = [],\n            otherCustomLinks = [];\n          visibleLinks.forEach(function (d) {\n            return ({\n              before: beforeCustomLinks,\n              after: afterCustomLinks,\n              replace: replaceCustomLinks\n            }[getLinkCanvasObjectMode(d)] || otherCustomLinks).push(d);\n          });\n          defaultPaintLinks = [].concat(_toConsumableArray(beforeCustomLinks), afterCustomLinks, otherCustomLinks);\n          beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);\n        }\n\n        // Custom link before paints\n        ctx.save();\n        beforeCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        // Bundle strokes per unique color/width/dash for performance optimization\n        var linksPerColor = (0,index_array_by__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(defaultPaintLinks, [getColor, getWidth, getLineDash]);\n        ctx.save();\n        Object.entries(linksPerColor).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            color = _ref2[0],\n            linksPerWidth = _ref2[1];\n          var lineColor = !color || color === 'undefined' ? 'rgba(0,0,0,0.15)' : color;\n          Object.entries(linksPerWidth).forEach(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n              width = _ref4[0],\n              linesPerLineDash = _ref4[1];\n            var lineWidth = (width || 1) / state.globalScale + padAmount;\n            Object.entries(linesPerLineDash).forEach(function (_ref5) {\n              var _ref6 = _slicedToArray(_ref5, 2);\n                _ref6[0];\n                var links = _ref6[1];\n              var lineDashSegments = getLineDash(links[0]);\n              ctx.beginPath();\n              links.forEach(function (link) {\n                var start = link.source;\n                var end = link.target;\n                if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n                ctx.moveTo(start.x, start.y);\n                var controlPoints = link.__controlPoints;\n                if (!controlPoints) {\n                  // Straight line\n                  ctx.lineTo(end.x, end.y);\n                } else {\n                  // Use quadratic curves for regular lines and bezier for loops\n                  ctx[controlPoints.length === 2 ? 'quadraticCurveTo' : 'bezierCurveTo'].apply(ctx, _toConsumableArray(controlPoints).concat([end.x, end.y]));\n                }\n              });\n              ctx.strokeStyle = lineColor;\n              ctx.lineWidth = lineWidth;\n              ctx.setLineDash(lineDashSegments || []);\n              ctx.stroke();\n            });\n          });\n        });\n        ctx.restore();\n\n        // Custom link after paints\n        ctx.save();\n        afterCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        //\n\n        function calcLinkControlPoints(link) {\n          var curvature = getCurvature(link);\n          if (!curvature) {\n            // straight line\n            link.__controlPoints = null;\n            return;\n          }\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var l = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)); // line length\n\n          if (l > 0) {\n            var a = Math.atan2(end.y - start.y, end.x - start.x); // line angle\n            var d = l * curvature; // control point distance\n\n            var cp = {\n              // control point\n              x: (start.x + end.x) / 2 + d * Math.cos(a - Math.PI / 2),\n              y: (start.y + end.y) / 2 + d * Math.sin(a - Math.PI / 2)\n            };\n            link.__controlPoints = [cp.x, cp.y];\n          } else {\n            // Same point, draw a loop\n            var _d = curvature * 70;\n            link.__controlPoints = [end.x, end.y - _d, end.x + _d, end.y];\n          }\n        }\n      }\n      function paintArrows() {\n        var ARROW_WH_RATIO = 1.6;\n        var ARROW_VLEN_RATIO = 0.2;\n        var getLength = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowLength);\n        var getRelPos = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowRelPos);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowColor || state.linkColor);\n        var getNodeVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var arrowLength = getLength(link);\n          if (!arrowLength || arrowLength < 0) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var startR = Math.sqrt(Math.max(0, getNodeVal(start) || 1)) * state.nodeRelSize;\n          var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;\n          var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link)));\n          var arrowColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints && _construct(bezier_js__WEBPACK_IMPORTED_MODULE_3__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y]));\n          var getCoordsAlongLine = bzLine ? function (t) {\n            return bzLine.get(t);\n          } // get position along bezier line\n          : function (t) {\n            return {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * t || 0,\n              y: start.y + (end.y - start.y) * t || 0\n            };\n          };\n          var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;\n          var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);\n          var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);\n          var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);\n          var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;\n          ctx.beginPath();\n          ctx.moveTo(arrowHead.x, arrowHead.y);\n          ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);\n          ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.fillStyle = arrowColor;\n          ctx.fill();\n        });\n        ctx.restore();\n      }\n      function paintPhotons() {\n        var getNumPhotons = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n        var getSpeed = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleSpeed);\n        var getDiameter = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleWidth);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleColor || state.linkColor);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var numCyclePhotons = getNumPhotons(link);\n          if (!link.hasOwnProperty('__photons') || !link.__photons.length) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var particleSpeed = getSpeed(link);\n          var photons = link.__photons || [];\n          var photonR = Math.max(0, getDiameter(link) / 2) / Math.sqrt(state.globalScale);\n          var photonColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          ctx.fillStyle = photonColor;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints ? _construct(bezier_js__WEBPACK_IMPORTED_MODULE_3__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y])) : null;\n          var cyclePhotonIdx = 0;\n          var needsCleanup = false; // whether some photons need to be removed from list\n          photons.forEach(function (photon) {\n            var singleHop = !!photon.__singleHop;\n            if (!photon.hasOwnProperty('__progressRatio')) {\n              photon.__progressRatio = singleHop ? 0 : cyclePhotonIdx / numCyclePhotons;\n            }\n            !singleHop && cyclePhotonIdx++; // increase regular photon index\n\n            photon.__progressRatio += particleSpeed;\n            if (photon.__progressRatio >= 1) {\n              if (!singleHop) {\n                photon.__progressRatio = photon.__progressRatio % 1;\n              } else {\n                needsCleanup = true;\n                return;\n              }\n            }\n            var photonPosRatio = photon.__progressRatio;\n            var coords = bzLine ? bzLine.get(photonPosRatio) // get position along bezier line\n            : {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * photonPosRatio || 0,\n              y: start.y + (end.y - start.y) * photonPosRatio || 0\n            };\n            ctx.beginPath();\n            ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);\n            ctx.fill();\n          });\n          if (needsCleanup) {\n            // remove expired single hop photons\n            link.__photons = link.__photons.filter(function (photon) {\n              return !photon.__singleHop || photon.__progressRatio <= 1;\n            });\n          }\n        });\n        ctx.restore();\n      }\n    },\n    emitParticle: function emitParticle(state, link) {\n      if (link) {\n        !link.__photons && (link.__photons = []);\n        link.__photons.push({\n          __singleHop: true\n        }); // add a single hop particle\n      }\n      return this;\n    }\n  },\n  stateInit: function stateInit() {\n    return {\n      forceLayout: (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_8__[\"default\"])().force('link', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_9__[\"default\"])()).force('charge', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_10__[\"default\"])()).force('center', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_11__[\"default\"])()).force('dagRadial', null).stop(),\n      engineRunning: false\n    };\n  },\n  init: function init(canvasCtx, state) {\n    // Main canvas object to manipulate\n    state.ctx = canvasCtx;\n  },\n  update: function update(state) {\n    state.engineRunning = false; // Pause simulation\n    state.onUpdate();\n    if (state.nodeAutoColorBy !== null) {\n      // Auto add color to uncolored nodes\n      autoColorObjects(state.graphData.nodes, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeAutoColorBy), state.nodeColor);\n    }\n    if (state.linkAutoColorBy !== null) {\n      // Auto add color to uncolored links\n      autoColorObjects(state.graphData.links, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkAutoColorBy), state.linkColor);\n    }\n\n    // parse links\n    state.graphData.links.forEach(function (link) {\n      link.source = link[state.linkSource];\n      link.target = link[state.linkTarget];\n    });\n\n    // Feed data to force-directed layout\n    state.forceLayout.stop().alpha(1) // re-heat the simulation\n    .nodes(state.graphData.nodes);\n\n    // add links (if link force is still active)\n    var linkForce = state.forceLayout.force('link');\n    if (linkForce) {\n      linkForce.id(function (d) {\n        return d[state.nodeId];\n      }).links(state.graphData.links);\n    }\n\n    // setup dag force constraints\n    var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {\n      return node[state.nodeId];\n    }, {\n      nodeFilter: state.dagNodeFilter,\n      onLoopError: state.onDagError || undefined\n    });\n    var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));\n    var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1);\n\n    // Fix nodes to x,y for dag mode\n    if (state.dagMode) {\n      var getFFn = function getFFn(fix, invert) {\n        return function (node) {\n          return !fix ? undefined : (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);\n        };\n      };\n      var fxFn = getFFn(['lr', 'rl'].indexOf(state.dagMode) !== -1, state.dagMode === 'rl');\n      var fyFn = getFFn(['td', 'bu'].indexOf(state.dagMode) !== -1, state.dagMode === 'bu');\n      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n        node.fx = fxFn(node);\n        node.fy = fyFn(node);\n      });\n    }\n\n    // Use radial force for radial dags\n    state.forceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(function (node) {\n      var nodeDepth = nodeDepths[node[state.nodeId]] || -1;\n      return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;\n    }).strength(function (node) {\n      return state.dagNodeFilter(node) ? 1 : 0;\n    }) : null);\n    for (var i = 0; i < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin); i++) {\n      state.forceLayout.tick();\n    } // Initial ticks before starting to render\n\n    this.resetCountdown();\n    state.onFinishUpdate();\n  }\n});\n\nfunction linkKapsule (kapsulePropNames, kapsuleType) {\n  var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];\n  var dummyK = new kapsuleType(); // To extract defaults\n  dummyK._destructor && dummyK._destructor();\n  return {\n    linkProp: function linkProp(prop) {\n      // link property config\n      return {\n        \"default\": dummyK[prop](),\n        onChange: function onChange(v, state) {\n          propNames.forEach(function (propName) {\n            return state[propName][prop](v);\n          });\n        },\n        triggerUpdate: false\n      };\n    },\n    linkMethod: function linkMethod(method) {\n      // link method pass-through\n      return function (state) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        var returnVals = [];\n        propNames.forEach(function (propName) {\n          var kapsuleInstance = state[propName];\n          var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);\n          if (returnVal !== kapsuleInstance) {\n            returnVals.push(returnVal);\n          }\n        });\n        return returnVals.length ? returnVals[0] : this; // chain based on the parent object, not the inner kapsule\n      };\n    }\n  };\n}\n\nvar HOVER_CANVAS_THROTTLE_DELAY = 800; // ms to throttle shadow canvas updates for perf improvement\nvar ZOOM2NODES_FACTOR = 4;\n\n// Expose config from forceGraph\nvar bindFG = linkKapsule('forceGraph', CanvasForceGraph);\nvar bindBoth = linkKapsule(['forceGraph', 'shadowGraph'], CanvasForceGraph);\nvar linkedProps = Object.assign.apply(Object, _toConsumableArray(['nodeColor', 'nodeAutoColorBy', 'nodeCanvasObject', 'nodeCanvasObjectMode', 'linkColor', 'linkAutoColorBy', 'linkLineDash', 'linkWidth', 'linkCanvasObject', 'linkCanvasObjectMode', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'dagMode', 'dagLevelDistance', 'dagNodeFilter', 'onDagError', 'd3AlphaMin', 'd3AlphaDecay', 'd3VelocityDecay', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkProp(p));\n})).concat(_toConsumableArray(['nodeRelSize', 'nodeId', 'nodeVal', 'nodeVisibility', 'linkSource', 'linkTarget', 'linkVisibility', 'linkCurvature'].map(function (p) {\n  return _defineProperty({}, p, bindBoth.linkProp(p));\n}))));\nvar linkedMethods = Object.assign.apply(Object, _toConsumableArray(['d3Force', 'd3ReheatSimulation', 'emitParticle'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkMethod(p));\n})));\nfunction adjustCanvasSize(state) {\n  if (state.canvas) {\n    var curWidth = state.canvas.width;\n    var curHeight = state.canvas.height;\n    if (curWidth === 300 && curHeight === 150) {\n      // Default canvas dimensions\n      curWidth = curHeight = 0;\n    }\n    var pxScale = window.devicePixelRatio; // 2 on retina displays\n    curWidth /= pxScale;\n    curHeight /= pxScale;\n\n    // Resize canvases\n    [state.canvas, state.shadowCanvas].forEach(function (canvas) {\n      // Element size\n      canvas.style.width = \"\".concat(state.width, \"px\");\n      canvas.style.height = \"\".concat(state.height, \"px\");\n\n      // Memory size (scaled to avoid blurriness)\n      canvas.width = state.width * pxScale;\n      canvas.height = state.height * pxScale;\n\n      // Normalize coordinate system to use css pixels (on init only)\n      if (!curWidth && !curHeight) {\n        canvas.getContext('2d').scale(pxScale, pxScale);\n      }\n    });\n\n    // Relative center panning based on 0,0\n    var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n    state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k, (state.height - curHeight) / 2 / k);\n    state.needsRedraw = true;\n  }\n}\nfunction resetTransform(ctx) {\n  var pxRatio = window.devicePixelRatio;\n  ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);\n}\nfunction clearCanvas(ctx, width, height) {\n  ctx.save();\n  resetTransform(ctx); // reset transform\n  ctx.clearRect(0, 0, width, height);\n  ctx.restore(); //restore transforms\n}\n\n//\n\nvar forceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n  props: _objectSpread2({\n    width: {\n      \"default\": window.innerWidth,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    height: {\n      \"default\": window.innerHeight,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(d, state) {\n        [{\n          type: 'Node',\n          objs: d.nodes\n        }, {\n          type: 'Link',\n          objs: d.links\n        }].forEach(hexIndex);\n        state.forceGraph.graphData(d);\n        state.shadowGraph.graphData(d);\n        function hexIndex(_ref4) {\n          var type = _ref4.type,\n            objs = _ref4.objs;\n          objs.filter(function (d) {\n            if (!d.hasOwnProperty('__indexColor')) return true;\n            var cur = state.colorTracker.lookup(d.__indexColor);\n            return !cur || !cur.hasOwnProperty('d') || cur.d !== d;\n          }).forEach(function (d) {\n            // store object lookup color\n            d.__indexColor = state.colorTracker.register({\n              type: type,\n              d: d\n            });\n          });\n        }\n      },\n      triggerUpdate: false\n    },\n    backgroundColor: {\n      onChange: function onChange(color, state) {\n        state.canvas && color && (state.canvas.style.background = color);\n      },\n      triggerUpdate: false\n    },\n    nodeLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    nodePointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.nodeCanvasObject(!paintFn ? null : function (node, ctx, globalScale) {\n          return paintFn(node, node.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkPointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.linkCanvasObject(!paintFn ? null : function (link, ctx, globalScale) {\n          return paintFn(link, link.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    linkHoverPrecision: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    minZoom: {\n      \"default\": 0.01,\n      onChange: function onChange(minZoom, state) {\n        state.zoom.scaleExtent([minZoom, state.zoom.scaleExtent()[1]]);\n      },\n      triggerUpdate: false\n    },\n    maxZoom: {\n      \"default\": 1000,\n      onChange: function onChange(maxZoom, state) {\n        state.zoom.scaleExtent([state.zoom.scaleExtent()[0], maxZoom]);\n      },\n      triggerUpdate: false\n    },\n    enableNodeDrag: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enablePanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomPanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    // to be deprecated\n    enablePointerInteraction: {\n      \"default\": true,\n      onChange: function onChange(_, state) {\n        state.hoverObj = null;\n      },\n      triggerUpdate: false\n    },\n    autoPauseRedraw: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    onNodeDrag: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeDragEnd: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeClick: {\n      triggerUpdate: false\n    },\n    onNodeRightClick: {\n      triggerUpdate: false\n    },\n    onNodeHover: {\n      triggerUpdate: false\n    },\n    onLinkClick: {\n      triggerUpdate: false\n    },\n    onLinkRightClick: {\n      triggerUpdate: false\n    },\n    onLinkHover: {\n      triggerUpdate: false\n    },\n    onBackgroundClick: {\n      triggerUpdate: false\n    },\n    onBackgroundRightClick: {\n      triggerUpdate: false\n    },\n    onZoom: {\n      triggerUpdate: false\n    },\n    onZoomEnd: {\n      triggerUpdate: false\n    },\n    onRenderFramePre: {\n      triggerUpdate: false\n    },\n    onRenderFramePost: {\n      triggerUpdate: false\n    }\n  }, linkedProps),\n  aliases: {\n    // Prop names supported for backwards compatibility\n    stopAnimation: 'pauseAnimation'\n  },\n  methods: _objectSpread2({\n    graph2ScreenCoords: function graph2ScreenCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: x * t.k + t.x,\n        y: y * t.k + t.y\n      };\n    },\n    screen2GraphCoords: function screen2GraphCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: (x - t.x) / t.k,\n        y: (y - t.y) / t.k\n      };\n    },\n    centerAt: function centerAt(state, x, y, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (x !== undefined || y !== undefined) {\n        var finalPos = Object.assign({}, x !== undefined ? {\n          x: x\n        } : {}, y !== undefined ? {\n          y: y\n        } : {});\n        if (!transitionDuration) {\n          // no animation\n          setCenter(finalPos);\n        } else {\n          new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween(getCenter()).to(finalPos, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(setCenter).start();\n        }\n        return this;\n      }\n\n      // getter\n      return getCenter();\n\n      //\n\n      function getCenter() {\n        var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n        return {\n          x: (state.width / 2 - t.x) / t.k,\n          y: (state.height / 2 - t.y) / t.k\n        };\n      }\n      function setCenter(_ref5) {\n        var x = _ref5.x,\n          y = _ref5.y;\n        state.zoom.translateTo(state.zoom.__baseElem, x === undefined ? getCenter().x : x, y === undefined ? getCenter().y : y);\n        state.needsRedraw = true;\n      }\n    },\n    zoom: function zoom(state, k, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (k !== undefined) {\n        if (!transitionDuration) {\n          // no animation\n          setZoom(k);\n        } else {\n          new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween({\n            k: getZoom()\n          }).to({\n            k: k\n          }, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(function (_ref6) {\n            var k = _ref6.k;\n            return setZoom(k);\n          }).start();\n        }\n        return this;\n      }\n\n      // getter\n      return getZoom();\n\n      //\n\n      function getZoom() {\n        return (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      }\n      function setZoom(k) {\n        state.zoom.scaleTo(state.zoom.__baseElem, k);\n        state.needsRedraw = true;\n      }\n    },\n    zoomToFit: function zoomToFit(state) {\n      var transitionDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        bboxArgs[_key - 3] = arguments[_key];\n      }\n      var bbox = this.getGraphBbox.apply(this, bboxArgs);\n      if (bbox) {\n        var center = {\n          x: (bbox.x[0] + bbox.x[1]) / 2,\n          y: (bbox.y[0] + bbox.y[1]) / 2\n        };\n        var zoomK = Math.max(1e-12, Math.min(1e12, (state.width - padding * 2) / (bbox.x[1] - bbox.x[0]), (state.height - padding * 2) / (bbox.y[1] - bbox.y[0])));\n        this.centerAt(center.x, center.y, transitionDuration);\n        this.zoom(zoomK, transitionDuration);\n      }\n      return this;\n    },\n    getGraphBbox: function getGraphBbox(state) {\n      var nodeFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n      var getR = function getR(node) {\n        return Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize;\n      };\n      var nodesPos = state.graphData.nodes.filter(nodeFilter).map(function (node) {\n        return {\n          x: node.x,\n          y: node.y,\n          r: getR(node)\n        };\n      });\n      return !nodesPos.length ? null : {\n        x: [(0,d3_array__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(nodesPos, function (node) {\n          return node.x - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.x + node.r;\n        })],\n        y: [(0,d3_array__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(nodesPos, function (node) {\n          return node.y - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.y + node.r;\n        })]\n      };\n    },\n    pauseAnimation: function pauseAnimation(state) {\n      if (state.animationFrameRequestId) {\n        cancelAnimationFrame(state.animationFrameRequestId);\n        state.animationFrameRequestId = null;\n      }\n      return this;\n    },\n    resumeAnimation: function resumeAnimation(state) {\n      if (!state.animationFrameRequestId) {\n        this._animationCycle();\n      }\n      return this;\n    },\n    _destructor: function _destructor() {\n      this.pauseAnimation();\n      this.graphData({\n        nodes: [],\n        links: []\n      });\n    }\n  }, linkedMethods),\n  stateInit: function stateInit() {\n    return {\n      lastSetZoom: 1,\n      zoom: (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)(),\n      forceGraph: new CanvasForceGraph(),\n      shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor('__indexColor').linkColor('__indexColor').isShadow(true),\n      colorTracker: new canvas_color_tracker__WEBPACK_IMPORTED_MODULE_15__[\"default\"]() // indexed objects for rgb lookup\n    };\n  },\n  init: function init(domNode, state) {\n    var _this = this;\n    // Wipe DOM\n    domNode.innerHTML = '';\n\n    // Container anchor for canvas and tooltip\n    var container = document.createElement('div');\n    container.classList.add('force-graph-container');\n    container.style.position = 'relative';\n    domNode.appendChild(container);\n    state.canvas = document.createElement('canvas');\n    if (state.backgroundColor) state.canvas.style.background = state.backgroundColor;\n    container.appendChild(state.canvas);\n    state.shadowCanvas = document.createElement('canvas');\n\n    // Show shadow canvas\n    //state.shadowCanvas.style.position = 'absolute';\n    //state.shadowCanvas.style.top = '0';\n    //state.shadowCanvas.style.left = '0';\n    //container.appendChild(state.shadowCanvas);\n\n    var ctx = state.canvas.getContext('2d');\n    var shadowCtx = state.shadowCanvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    var pointerPos = {\n      x: -1e12,\n      y: -1e12\n    };\n    var getObjUnderPointer = function getObjUnderPointer() {\n      var obj = null;\n      var pxScale = window.devicePixelRatio;\n      var px = pointerPos.x > 0 && pointerPos.y > 0 ? shadowCtx.getImageData(pointerPos.x * pxScale, pointerPos.y * pxScale, 1, 1) : null;\n      // Lookup object per pixel color\n      px && (obj = state.colorTracker.lookup(px.data));\n      return obj;\n    };\n\n    // Setup node drag interaction\n    (0,d3_selection__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(state.canvas).call((0,d3_drag__WEBPACK_IMPORTED_MODULE_17__[\"default\"])().subject(function () {\n      if (!state.enableNodeDrag) {\n        return null;\n      }\n      var obj = getObjUnderPointer();\n      return obj && obj.type === 'Node' ? obj.d : null; // Only drag nodes\n    }).on('start', function (ev) {\n      var obj = ev.subject;\n      obj.__initialDragPos = {\n        x: obj.x,\n        y: obj.y,\n        fx: obj.fx,\n        fy: obj.fy\n      };\n\n      // keep engine running at low intensity throughout drag\n      if (!ev.active) {\n        obj.fx = obj.x;\n        obj.fy = obj.y; // Fix points\n      }\n\n      // drag cursor\n      state.canvas.classList.add('grabbable');\n    }).on('drag', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var dragPos = ev;\n      var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      var translate = {\n        x: initPos.x + (dragPos.x - initPos.x) / k - obj.x,\n        y: initPos.y + (dragPos.y - initPos.y) / k - obj.y\n      };\n\n      // Move fx/fy (and x/y) of nodes based on the scaled drag distance since the drag start\n      ['x', 'y'].forEach(function (c) {\n        return obj[\"f\".concat(c)] = obj[c] = initPos[c] + (dragPos[c] - initPos[c]) / k;\n      });\n\n      // prevent freeze while dragging\n      state.forceGraph.d3AlphaTarget(0.3) // keep engine running at low intensity throughout drag\n      .resetCountdown(); // prevent freeze while dragging\n\n      state.isPointerDragging = true;\n      obj.__dragged = true;\n      state.onNodeDrag(obj, translate);\n    }).on('end', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var translate = {\n        x: obj.x - initPos.x,\n        y: obj.y - initPos.y\n      };\n      if (initPos.fx === undefined) {\n        obj.fx = undefined;\n      }\n      if (initPos.fy === undefined) {\n        obj.fy = undefined;\n      }\n      delete obj.__initialDragPos;\n      if (state.forceGraph.d3AlphaTarget()) {\n        state.forceGraph.d3AlphaTarget(0) // release engine low intensity\n        .resetCountdown(); // let the engine readjust after releasing fixed nodes\n      }\n\n      // drag cursor\n      state.canvas.classList.remove('grabbable');\n      state.isPointerDragging = false;\n      if (obj.__dragged) {\n        delete obj.__dragged;\n        state.onNodeDragEnd(obj, translate);\n      }\n    }));\n\n    // Setup zoom / pan interaction\n    state.zoom(state.zoom.__baseElem = (0,d3_selection__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(state.canvas)); // Attach controlling elem for easy access\n\n    state.zoom.__baseElem.on('dblclick.zoom', null); // Disable double-click to zoom\n\n    state.zoom.filter(function (ev) {\n      return (\n        // disable zoom interaction\n        !ev.button && state.enableZoomPanInteraction && (state.enableZoomInteraction || ev.type !== 'wheel') && (state.enablePanInteraction || ev.type === 'wheel')\n      );\n    }).on('zoom', function (ev) {\n      var t = ev.transform;\n      [ctx, shadowCtx].forEach(function (c) {\n        resetTransform(c);\n        c.translate(t.x, t.y);\n        c.scale(t.k, t.k);\n      });\n      state.onZoom && state.onZoom(_objectSpread2(_objectSpread2({}, t), _this.centerAt())); // report x,y coordinates relative to canvas center\n      state.needsRedraw = true;\n    }).on('end', function (ev) {\n      return state.onZoomEnd && state.onZoomEnd(_objectSpread2(_objectSpread2({}, ev.transform), _this.centerAt()));\n    });\n    adjustCanvasSize(state);\n    state.forceGraph.onNeedsRedraw(function () {\n      return state.needsRedraw = true;\n    }).onFinishUpdate(function () {\n      // re-zoom, if still in default position (not user modified)\n      if ((0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {\n        state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));\n        state.needsRedraw = true;\n      }\n    });\n\n    // Setup tooltip\n    var toolTipElem = document.createElement('div');\n    toolTipElem.classList.add('graph-tooltip');\n    container.appendChild(toolTipElem);\n\n    // Capture pointer coords on move or touchstart\n    ['pointermove', 'pointerdown'].forEach(function (evType) {\n      return container.addEventListener(evType, function (ev) {\n        if (evType === 'pointerdown') {\n          state.isPointerPressed = true; // track click state\n          state.pointerDownEvent = ev;\n        }\n\n        // detect pointer drag on canvas pan\n        !state.isPointerDragging && ev.type === 'pointermove' && state.onBackgroundClick // only bother detecting drags this way if background clicks are enabled (so they don't trigger accidentally on canvas panning)\n        && (ev.pressure > 0 || state.isPointerPressed) // ev.pressure always 0 on Safari, so we use the isPointerPressed tracker\n        && (ev.pointerType !== 'touch' || ev.movementX === undefined || [ev.movementX, ev.movementY].some(function (m) {\n          return Math.abs(m) > 1;\n        })) // relax drag trigger sensitivity on touch events\n        && (state.isPointerDragging = true);\n\n        // update the pointer pos\n        var offset = getOffset(container);\n        pointerPos.x = ev.pageX - offset.left;\n        pointerPos.y = ev.pageY - offset.top;\n\n        // Move tooltip\n        toolTipElem.style.top = \"\".concat(pointerPos.y, \"px\");\n        toolTipElem.style.left = \"\".concat(pointerPos.x, \"px\");\n\n        // adjust horizontal position to not exceed canvas boundaries\n        toolTipElem.style.transform = \"translate(-\".concat(pointerPos.x / state.width * 100, \"%, \").concat(\n        // flip to above if near bottom\n        state.height - pointerPos.y < 100 ? 'calc(-100% - 8px)' : '21px', \")\");\n\n        //\n\n        function getOffset(el) {\n          var rect = el.getBoundingClientRect(),\n            scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\n            scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n          return {\n            top: rect.top + scrollTop,\n            left: rect.left + scrollLeft\n          };\n        }\n      }, {\n        passive: true\n      });\n    });\n\n    // Handle click/touch events on nodes/links\n    container.addEventListener('pointerup', function (ev) {\n      state.isPointerPressed = false;\n      if (state.isPointerDragging) {\n        state.isPointerDragging = false;\n        return; // don't trigger click events after pointer drag (pan / node drag functionality)\n      }\n      var cbEvents = [ev, state.pointerDownEvent];\n      requestAnimationFrame(function () {\n        // trigger click events asynchronously, to allow hoverObj to be set (on frame)\n        if (ev.button === 0) {\n          // mouse left-click or touch\n          if (state.hoverObj) {\n            var fn = state[\"on\".concat(state.hoverObj.type, \"Click\")];\n            fn && fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundClick && state.onBackgroundClick.apply(state, cbEvents);\n          }\n        }\n        if (ev.button === 2) {\n          // mouse right-click\n          if (state.hoverObj) {\n            var _fn = state[\"on\".concat(state.hoverObj.type, \"RightClick\")];\n            _fn && _fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundRightClick && state.onBackgroundRightClick.apply(state, cbEvents);\n          }\n        }\n      });\n    }, {\n      passive: true\n    });\n    container.addEventListener('contextmenu', function (ev) {\n      if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick) return true; // default contextmenu behavior\n      ev.preventDefault();\n      return false;\n    });\n    state.forceGraph(ctx);\n    state.shadowGraph(shadowCtx);\n\n    //\n\n    var refreshShadowCanvas = (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(function () {\n      // wipe canvas\n      clearCanvas(shadowCtx, state.width, state.height);\n\n      // Adjust link hover area\n      state.shadowGraph.linkWidth(function (l) {\n        return (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth)(l) + state.linkHoverPrecision;\n      });\n\n      // redraw\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      state.shadowGraph.globalScale(t.k).tickFrame();\n    }, HOVER_CANVAS_THROTTLE_DELAY);\n    state.flushShadowCanvas = refreshShadowCanvas.flush; // hook to immediately invoke shadow canvas paint\n\n    // Kick-off renderer\n    (this._animationCycle = function animate() {\n      // IIFE\n      var doRedraw = !state.autoPauseRedraw || !!state.needsRedraw || state.forceGraph.isEngineRunning() || state.graphData.links.some(function (d) {\n        return d.__photons && d.__photons.length;\n      });\n      state.needsRedraw = false;\n      if (state.enablePointerInteraction) {\n        // Update tooltip and trigger onHover events\n        var obj = !state.isPointerDragging ? getObjUnderPointer() : null; // don't hover during drag\n        if (obj !== state.hoverObj) {\n          var prevObj = state.hoverObj;\n          var prevObjType = prevObj ? prevObj.type : null;\n          var objType = obj ? obj.type : null;\n          if (prevObjType && prevObjType !== objType) {\n            // Hover out\n            var fn = state[\"on\".concat(prevObjType, \"Hover\")];\n            fn && fn(null, prevObj.d);\n          }\n          if (objType) {\n            // Hover in\n            var _fn2 = state[\"on\".concat(objType, \"Hover\")];\n            _fn2 && _fn2(obj.d, prevObjType === objType ? prevObj.d : null);\n          }\n          var tooltipContent = obj ? (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state[\"\".concat(obj.type.toLowerCase(), \"Label\")])(obj.d) || '' : '';\n          toolTipElem.style.visibility = tooltipContent ? 'visible' : 'hidden';\n          toolTipElem.innerHTML = tooltipContent;\n\n          // set pointer if hovered object is clickable\n          state.canvas.classList[obj && state[\"on\".concat(objType, \"Click\")] || !obj && state.onBackgroundClick ? 'add' : 'remove']('clickable');\n          state.hoverObj = obj;\n        }\n        doRedraw && refreshShadowCanvas();\n      }\n      if (doRedraw) {\n        // Wipe canvas\n        clearCanvas(ctx, state.width, state.height);\n\n        // Frame cycle\n        var globalScale = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n        state.onRenderFramePre && state.onRenderFramePre(ctx, globalScale);\n        state.forceGraph.globalScale(globalScale).tickFrame();\n        state.onRenderFramePost && state.onRenderFramePost(ctx, globalScale);\n      }\n      _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.update(); // update canvas animation tweens\n\n      state.animationFrameRequestId = requestAnimationFrame(animate);\n    })();\n  },\n  update: function updateFn(state) {}\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZm9yY2UtZ3JhcGhAMS40My41L25vZGVfbW9kdWxlcy9mb3JjZS1ncmFwaC9kaXN0L2ZvcmNlLWdyYXBoLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUNRO0FBQ2Y7QUFDSztBQUNDO0FBQ007QUFDYjtBQUNPO0FBQ1c7QUFDa0Q7QUFDL0Q7QUFDRTtBQUNHO0FBQ1U7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsbUJBQW1CLHNCQUFzQixrQkFBa0IsNkNBQTZDLEdBQUcsMkNBQTJDLHVCQUF1QixXQUFXLDRCQUE0QixvQkFBb0IsaUJBQWlCLHVCQUF1QixnQkFBZ0IsaUNBQWlDLHdCQUF3QixtQkFBbUIsdUNBQXVDLG9CQUFvQixHQUFHLHVDQUF1QyxpQkFBaUIsaUJBQWlCLHNCQUFzQix5QkFBeUIsR0FBRyw4Q0FBOEMscUJBQXFCLDBCQUEwQiw2QkFBNkIsR0FBRztBQUNqdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWSxrRUFBa0U7QUFDdEYsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztB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b3VyY2VzIjpbIndlYnBhY2s6Ly9yYXBoYWVsc2FsYWphLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZvcmNlLWdyYXBoQDEuNDMuNS9ub2RlX21vZHVsZXMvZm9yY2UtZ3JhcGgvZGlzdC9mb3JjZS1ncmFwaC5tanM/M2I1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgem9vbSwgem9vbVRyYW5zZm9ybSB9IGZyb20gJ2QzLXpvb20nO1xuaW1wb3J0IHsgZHJhZyB9IGZyb20gJ2QzLWRyYWcnO1xuaW1wb3J0IHsgbWluLCBtYXggfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyB0aHJvdHRsZSB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgKiBhcyBUV0VFTiBmcm9tICdAdHdlZW5qcy90d2Vlbi5qcyc7XG5pbXBvcnQgS2Fwc3VsZSBmcm9tICdrYXBzdWxlJztcbmltcG9ydCBhY2Nlc3NvckZuIGZyb20gJ2FjY2Vzc29yLWZuJztcbmltcG9ydCBDb2xvclRyYWNrZXIgZnJvbSAnY2FudmFzLWNvbG9yLXRyYWNrZXInO1xuaW1wb3J0IHsgZm9yY2VTaW11bGF0aW9uLCBmb3JjZUxpbmssIGZvcmNlTWFueUJvZHksIGZvcmNlQ2VudGVyLCBmb3JjZVJhZGlhbCB9IGZyb20gJ2QzLWZvcmNlLTNkJztcbmltcG9ydCB7IEJlemllciB9IGZyb20gJ2Jlemllci1qcyc7XG5pbXBvcnQgaW5kZXhCeSBmcm9tICdpbmRleC1hcnJheS1ieSc7XG5pbXBvcnQgeyBzY2FsZU9yZGluYWwgfSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgeyBzY2hlbWVQYWlyZWQgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnO1xuXG5mdW5jdGlvbiBzdHlsZUluamVjdChjc3MsIHJlZikge1xuICBpZiAocmVmID09PSB2b2lkIDApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICBpZiAoaW5zZXJ0QXQgPT09ICd0b3AnKSB7XG4gICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgY3NzXzI0OHogPSBcIi5mb3JjZS1ncmFwaC1jb250YWluZXIgY2FudmFzIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuLmZvcmNlLWdyYXBoLWNvbnRhaW5lciAuZ3JhcGgtdG9vbHRpcCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIHBhZGRpbmc6IDRweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGNvbG9yOiAjZWVlO1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwLjY1KTtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjsgLyogYnkgZGVmYXVsdCAqL1xcbn1cXG5cXG4uZm9yY2UtZ3JhcGgtY29udGFpbmVyIC5jbGlja2FibGUge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4uZm9yY2UtZ3JhcGgtY29udGFpbmVyIC5ncmFiYmFibGUge1xcbiAgY3Vyc29yOiBtb3ZlO1xcbiAgY3Vyc29yOiBncmFiO1xcbiAgY3Vyc29yOiAtbW96LWdyYWI7XFxuICBjdXJzb3I6IC13ZWJraXQtZ3JhYjtcXG59XFxuXFxuLmZvcmNlLWdyYXBoLWNvbnRhaW5lciAuZ3JhYmJhYmxlOmFjdGl2ZSB7XFxuICBjdXJzb3I6IGdyYWJiaW5nO1xcbiAgY3Vyc29yOiAtbW96LWdyYWJiaW5nO1xcbiAgY3Vyc29yOiAtd2Via2l0LWdyYWJiaW5nO1xcbn1cXG5cIjtcbnN0eWxlSW5qZWN0KGNzc18yNDh6KTtcblxuZnVuY3Rpb24gX2NvbnN0cnVjdCh0LCBlLCByKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB2YXIgbyA9IFtudWxsXTtcbiAgby5wdXNoLmFwcGx5KG8sIGUpO1xuICB2YXIgcCA9IG5ldyAodC5iaW5kLmFwcGx5KHQsIG8pKSgpO1xuICByZXR1cm4gciAmJiBfc2V0UHJvdG90eXBlT2YocCwgci5wcm90b3R5cGUpLCBwO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IFN0cmluZyhpKTtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgYXV0b0NvbG9yU2NhbGUgPSBzY2FsZU9yZGluYWwoc2NoZW1lUGFpcmVkKTtcblxuLy8gQXV0b3NldCBhdHRyaWJ1dGUgY29sb3JGaWVsZCBieSBjb2xvckJ5QWNjZXNzb3IgcHJvcGVydHlcbi8vIElmIGFuIG9iamVjdCBoYXMgYWxyZWFkeSBhIGNvbG9yLCBkb24ndCBzZXQgaXRcbi8vIE9iamVjdHMgY2FuIGJlIG5vZGVzIG9yIGxpbmtzXG5mdW5jdGlvbiBhdXRvQ29sb3JPYmplY3RzKG9iamVjdHMsIGNvbG9yQnlBY2Nlc3NvciwgY29sb3JGaWVsZCkge1xuICBpZiAoIWNvbG9yQnlBY2Nlc3NvciB8fCB0eXBlb2YgY29sb3JGaWVsZCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgb2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiAhb2JqW2NvbG9yRmllbGRdO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYmpbY29sb3JGaWVsZF0gPSBhdXRvQ29sb3JTY2FsZShjb2xvckJ5QWNjZXNzb3Iob2JqKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREYWdEZXB0aHMgKF9yZWYsIGlkQWNjZXNzb3IpIHtcbiAgdmFyIG5vZGVzID0gX3JlZi5ub2RlcyxcbiAgICBsaW5rcyA9IF9yZWYubGlua3M7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgX3JlZjIkbm9kZUZpbHRlciA9IF9yZWYyLm5vZGVGaWx0ZXIsXG4gICAgbm9kZUZpbHRlciA9IF9yZWYyJG5vZGVGaWx0ZXIgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gOiBfcmVmMiRub2RlRmlsdGVyLFxuICAgIF9yZWYyJG9uTG9vcEVycm9yID0gX3JlZjIub25Mb29wRXJyb3IsXG4gICAgb25Mb29wRXJyb3IgPSBfcmVmMiRvbkxvb3BFcnJvciA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGxvb3BJZHMpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBEQUcgc3RydWN0dXJlISBGb3VuZCBjeWNsZSBpbiBub2RlIHBhdGg6IFwiLmNvbmNhdChsb29wSWRzLmpvaW4oJyAtPiAnKSwgXCIuXCIpO1xuICAgIH0gOiBfcmVmMiRvbkxvb3BFcnJvcjtcbiAgLy8gbGlua2VkIGdyYXBoXG4gIHZhciBncmFwaCA9IHt9O1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGdyYXBoW2lkQWNjZXNzb3Iobm9kZSldID0ge1xuICAgICAgZGF0YTogbm9kZSxcbiAgICAgIG91dDogW10sXG4gICAgICBkZXB0aDogLTEsXG4gICAgICBza2lwOiAhbm9kZUZpbHRlcihub2RlKVxuICAgIH07XG4gIH0pO1xuICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgIHZhciBzb3VyY2UgPSBfcmVmMy5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmMy50YXJnZXQ7XG4gICAgdmFyIHNvdXJjZUlkID0gZ2V0Tm9kZUlkKHNvdXJjZSk7XG4gICAgdmFyIHRhcmdldElkID0gZ2V0Tm9kZUlkKHRhcmdldCk7XG4gICAgaWYgKCFncmFwaC5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHRocm93IFwiTWlzc2luZyBzb3VyY2Ugbm9kZSB3aXRoIGlkOiBcIi5jb25jYXQoc291cmNlSWQpO1xuICAgIGlmICghZ3JhcGguaGFzT3duUHJvcGVydHkodGFyZ2V0SWQpKSB0aHJvdyBcIk1pc3NpbmcgdGFyZ2V0IG5vZGUgd2l0aCBpZDogXCIuY29uY2F0KHRhcmdldElkKTtcbiAgICB2YXIgc291cmNlTm9kZSA9IGdyYXBoW3NvdXJjZUlkXTtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IGdyYXBoW3RhcmdldElkXTtcbiAgICBzb3VyY2VOb2RlLm91dC5wdXNoKHRhcmdldE5vZGUpO1xuICAgIGZ1bmN0aW9uIGdldE5vZGVJZChub2RlKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZihub2RlKSA9PT0gJ29iamVjdCcgPyBpZEFjY2Vzc29yKG5vZGUpIDogbm9kZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgZm91bmRMb29wcyA9IFtdO1xuICB0cmF2ZXJzZShPYmplY3QudmFsdWVzKGdyYXBoKSk7XG4gIHZhciBub2RlRGVwdGhzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFt7fV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShPYmplY3QuZW50cmllcyhncmFwaCkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgIHZhciBfcmVmNSA9IF9zbGljZWRUb0FycmF5KF9yZWY0LCAyKSxcbiAgICAgIG5vZGUgPSBfcmVmNVsxXTtcbiAgICByZXR1cm4gIW5vZGUuc2tpcDtcbiAgfSkubWFwKGZ1bmN0aW9uIChfcmVmNikge1xuICAgIHZhciBfcmVmNyA9IF9zbGljZWRUb0FycmF5KF9yZWY2LCAyKSxcbiAgICAgIGlkID0gX3JlZjdbMF0sXG4gICAgICBub2RlID0gX3JlZjdbMV07XG4gICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgaWQsIG5vZGUuZGVwdGgpO1xuICB9KSkpKTtcbiAgcmV0dXJuIG5vZGVEZXB0aHM7XG4gIGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGVzKSB7XG4gICAgdmFyIG5vZGVTdGFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgdmFyIGN1cnJlbnREZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZVN0YWNrLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgIHZhciBsb29wID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlU3RhY2suc2xpY2Uobm9kZVN0YWNrLmluZGV4T2Yobm9kZSkpKSwgW25vZGVdKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gaWRBY2Nlc3NvcihkLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmb3VuZExvb3BzLnNvbWUoZnVuY3Rpb24gKGZvdW5kTG9vcCkge1xuICAgICAgICAgIHJldHVybiBmb3VuZExvb3AubGVuZ3RoID09PSBsb29wLmxlbmd0aCAmJiBmb3VuZExvb3AuZXZlcnkoZnVuY3Rpb24gKGlkLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCA9PT0gbG9vcFtpZHhdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGZvdW5kTG9vcHMucHVzaChsb29wKTtcbiAgICAgICAgICBvbkxvb3BFcnJvcihsb29wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTsgLy8gY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50RGVwdGggPiBub2RlLmRlcHRoKSB7XG4gICAgICAgIC8vIERvbid0IHVubmVjZXNzYXJpbHkgcmV2aXNpdCBjaHVua3Mgb2YgdGhlIGdyYXBoXG4gICAgICAgIG5vZGUuZGVwdGggPSBjdXJyZW50RGVwdGg7XG4gICAgICAgIHRyYXZlcnNlKG5vZGUub3V0LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGVTdGFjayksIFtub2RlXSksIGN1cnJlbnREZXB0aCArIChub2RlLnNraXAgPyAwIDogMSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChfbG9vcCgpKSBjb250aW51ZTtcbiAgICB9XG4gIH1cbn1cblxuLy9cblxudmFyIERBR19MRVZFTF9OT0RFX1JBVElPID0gMjtcblxuLy8gd2hlbmV2ZXIgc3R5bGluZyBwcm9wcyBhcmUgY2hhbmdlZCB0aGF0IHJlcXVpcmUgYSBjYW52YXMgcmVkcmF3XG52YXIgbm90aWZ5UmVkcmF3ID0gZnVuY3Rpb24gbm90aWZ5UmVkcmF3KF8sIHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5vbk5lZWRzUmVkcmF3ICYmIHN0YXRlLm9uTmVlZHNSZWRyYXcoKTtcbn07XG52YXIgdXBkRGF0YVBob3RvbnMgPSBmdW5jdGlvbiB1cGREYXRhUGhvdG9ucyhfLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmlzU2hhZG93KSB7XG4gICAgLy8gQWRkIHBob3RvbiBwYXJ0aWNsZXNcbiAgICB2YXIgbGlua1BhcnRpY2xlc0FjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMpO1xuICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICB2YXIgbnVtUGhvdG9ucyA9IE1hdGgucm91bmQoTWF0aC5hYnMobGlua1BhcnRpY2xlc0FjY2Vzc29yKGxpbmspKSk7XG4gICAgICBpZiAobnVtUGhvdG9ucykge1xuICAgICAgICBsaW5rLl9fcGhvdG9ucyA9IF90b0NvbnN1bWFibGVBcnJheShBcnJheShudW1QaG90b25zKSkubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGxpbmsuX19waG90b25zO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIENhbnZhc0ZvcmNlR3JhcGggPSBLYXBzdWxlKHtcbiAgcHJvcHM6IHtcbiAgICBncmFwaERhdGE6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgbGlua3M6IFtdXG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKF8sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSBmYWxzZTsgLy8gUGF1c2Ugc2ltdWxhdGlvblxuICAgICAgICB1cGREYXRhUGhvdG9ucyhfLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkYWdNb2RlOiB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZGFnTW9kZSwgc3RhdGUpIHtcbiAgICAgICAgLy8gdGQsIGJ1LCBsciwgcmwsIHJhZGlhbGluLCByYWRpYWxvdXRcbiAgICAgICAgIWRhZ01vZGUgJiYgKHN0YXRlLmdyYXBoRGF0YS5ub2RlcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBuLmZ4ID0gbi5meSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7IC8vIHVuZml4IG5vZGVzIHdoZW4gZGlzYWJsaW5nIGRhZyBtb2RlXG4gICAgICB9XG4gICAgfSxcbiAgICBkYWdMZXZlbERpc3RhbmNlOiB7fSxcbiAgICBkYWdOb2RlRmlsdGVyOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQobm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRGFnRXJyb3I6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBub2RlUmVsU2l6ZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDQsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIC8vIGFyZWEgcGVyIHZhbCB1bml0XG4gICAgbm9kZUlkOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ2lkJ1xuICAgIH0sXG4gICAgbm9kZVZhbDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICd2YWwnLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBub2RlQ29sb3I6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnY29sb3InLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBub2RlQXV0b0NvbG9yQnk6IHt9LFxuICAgIG5vZGVDYW52YXNPYmplY3Q6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbm9kZUNhbnZhc09iamVjdE1vZGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdyZXBsYWNlJztcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIG5vZGVWaXNpYmlsaXR5OiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua1NvdXJjZToge1xuICAgICAgXCJkZWZhdWx0XCI6ICdzb3VyY2UnXG4gICAgfSxcbiAgICBsaW5rVGFyZ2V0OiB7XG4gICAgICBcImRlZmF1bHRcIjogJ3RhcmdldCdcbiAgICB9LFxuICAgIGxpbmtWaXNpYmlsaXR5OiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0NvbG9yOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ2NvbG9yJyxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0F1dG9Db2xvckJ5OiB7fSxcbiAgICBsaW5rTGluZURhc2g6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua1dpZHRoOiB7XG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0N1cnZhdHVyZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtDYW52YXNPYmplY3Q6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0NhbnZhc09iamVjdE1vZGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdyZXBsYWNlJztcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvczoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgLy8gdmFsdWUgYmV0d2VlbiAwPD4xIGluZGljYXRpbmcgdGhlIHJlbGF0aXZlIHBvcyBhbG9uZyB0aGUgKGV4cG9zZWQpIGxpbmVcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXM6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogdXBkRGF0YVBob3RvbnNcbiAgICB9LFxuICAgIC8vIGFuaW1hdGUgcGhvdG9ucyB0cmF2ZWxsaW5nIGluIHRoZSBsaW5rIGRpcmVjdGlvblxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlU3BlZWQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjAxLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIGluIGxpbmsgbGVuZ3RoIHJhdGlvIHBlciBmcmFtZVxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlV2lkdGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiA0LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3I6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBnbG9iYWxTY2FsZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZDNBbHBoYU1pbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZDNBbHBoYURlY2F5OiB7XG4gICAgICBcImRlZmF1bHRcIjogMC4wMjI4LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoYWxwaGFEZWNheSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGFEZWNheShhbHBoYURlY2F5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQzQWxwaGFUYXJnZXQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoYWxwaGFUYXJnZXQsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LmFscGhhVGFyZ2V0KGFscGhhVGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQzVmVsb2NpdHlEZWNheToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHZlbG9jaXR5RGVjYXksIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LnZlbG9jaXR5RGVjYXkodmVsb2NpdHlEZWNheSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXJtdXBUaWNrczoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gaG93IG1hbnkgdGltZXMgdG8gdGljayB0aGUgZm9yY2UgZW5naW5lIGF0IGluaXQgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlbmRlclxuICAgIGNvb2xkb3duVGlja3M6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBJbmZpbml0eSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBjb29sZG93blRpbWU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAxNTAwMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBtc1xuICAgIG9uVXBkYXRlOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkZpbmlzaFVwZGF0ZToge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25FbmdpbmVUaWNrOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkVuZ2luZVN0b3A6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTmVlZHNSZWRyYXc6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBpc1NoYWRvdzoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICAvLyBFeHBvc2UgZDMgZm9yY2VzIGZvciBleHRlcm5hbCBtYW5pcHVsYXRpb25cbiAgICBkM0ZvcmNlOiBmdW5jdGlvbiBkM0ZvcmNlKHN0YXRlLCBmb3JjZU5hbWUsIGZvcmNlRm4pIHtcbiAgICAgIGlmIChmb3JjZUZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmZvcmNlTGF5b3V0LmZvcmNlKGZvcmNlTmFtZSk7IC8vIEZvcmNlIGdldHRlclxuICAgICAgfVxuICAgICAgc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoZm9yY2VOYW1lLCBmb3JjZUZuKTsgLy8gRm9yY2Ugc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGQzUmVoZWF0U2ltdWxhdGlvbjogZnVuY3Rpb24gZDNSZWhlYXRTaW11bGF0aW9uKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5mb3JjZUxheW91dC5hbHBoYSgxKTtcbiAgICAgIHRoaXMucmVzZXRDb3VudGRvd24oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gcmVzZXQgY29vbGRvd24gc3RhdGVcbiAgICByZXNldENvdW50ZG93bjogZnVuY3Rpb24gcmVzZXRDb3VudGRvd24oc3RhdGUpIHtcbiAgICAgIHN0YXRlLmNudFRpY2tzID0gMDtcbiAgICAgIHN0YXRlLnN0YXJ0VGlja1RpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgc3RhdGUuZW5naW5lUnVubmluZyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGlzRW5naW5lUnVubmluZzogZnVuY3Rpb24gaXNFbmdpbmVSdW5uaW5nKHN0YXRlKSB7XG4gICAgICByZXR1cm4gISFzdGF0ZS5lbmdpbmVSdW5uaW5nO1xuICAgIH0sXG4gICAgdGlja0ZyYW1lOiBmdW5jdGlvbiB0aWNrRnJhbWUoc3RhdGUpIHtcbiAgICAgICFzdGF0ZS5pc1NoYWRvdyAmJiBsYXlvdXRUaWNrKCk7XG4gICAgICBwYWludExpbmtzKCk7XG4gICAgICAhc3RhdGUuaXNTaGFkb3cgJiYgcGFpbnRBcnJvd3MoKTtcbiAgICAgICFzdGF0ZS5pc1NoYWRvdyAmJiBwYWludFBob3RvbnMoKTtcbiAgICAgIHBhaW50Tm9kZXMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvL1xuXG4gICAgICBmdW5jdGlvbiBsYXlvdXRUaWNrKCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5naW5lUnVubmluZykge1xuICAgICAgICAgIGlmICgrK3N0YXRlLmNudFRpY2tzID4gc3RhdGUuY29vbGRvd25UaWNrcyB8fCBuZXcgRGF0ZSgpIC0gc3RhdGUuc3RhcnRUaWNrVGltZSA+IHN0YXRlLmNvb2xkb3duVGltZSB8fCBzdGF0ZS5kM0FscGhhTWluID4gMCAmJiBzdGF0ZS5mb3JjZUxheW91dC5hbHBoYSgpIDwgc3RhdGUuZDNBbHBoYU1pbikge1xuICAgICAgICAgICAgc3RhdGUuZW5naW5lUnVubmluZyA9IGZhbHNlOyAvLyBTdG9wIHRpY2tpbmcgZ3JhcGhcbiAgICAgICAgICAgIHN0YXRlLm9uRW5naW5lU3RvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5mb3JjZUxheW91dC50aWNrKCk7IC8vIFRpY2sgaXRcbiAgICAgICAgICAgIHN0YXRlLm9uRW5naW5lVGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFpbnROb2RlcygpIHtcbiAgICAgICAgdmFyIGdldFZpc2liaWxpdHkgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVWaXNpYmlsaXR5KTtcbiAgICAgICAgdmFyIGdldFZhbCA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZhbCk7XG4gICAgICAgIHZhciBnZXRDb2xvciA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZUNvbG9yKTtcbiAgICAgICAgdmFyIGdldE5vZGVDYW52YXNPYmplY3RNb2RlID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlQ2FudmFzT2JqZWN0TW9kZSk7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jdHg7XG5cbiAgICAgICAgLy8gRHJhdyB3aWRlciBub2RlcyBieSAxcHggb24gc2hhZG93IGNhbnZhcyBmb3IgbW9yZSBwcmVjaXNlIGhvdmVyaW5nIChkdWUgdG8gYm91bmRhcnkgYW50aS1hbGlhc2luZylcbiAgICAgICAgdmFyIHBhZEFtb3VudCA9IHN0YXRlLmlzU2hhZG93IC8gc3RhdGUuZ2xvYmFsU2NhbGU7XG4gICAgICAgIHZhciB2aXNpYmxlTm9kZXMgPSBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmlsdGVyKGdldFZpc2liaWxpdHkpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICB2aXNpYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciBub2RlQ2FudmFzT2JqZWN0TW9kZSA9IGdldE5vZGVDYW52YXNPYmplY3RNb2RlKG5vZGUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5ub2RlQ2FudmFzT2JqZWN0ICYmIChub2RlQ2FudmFzT2JqZWN0TW9kZSA9PT0gJ2JlZm9yZScgfHwgbm9kZUNhbnZhc09iamVjdE1vZGUgPT09ICdyZXBsYWNlJykpIHtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBub2RlIGJlZm9yZS9yZXBsYWNlIHBhaW50XG4gICAgICAgICAgICBzdGF0ZS5ub2RlQ2FudmFzT2JqZWN0KG5vZGUsIGN0eCwgc3RhdGUuZ2xvYmFsU2NhbGUpO1xuICAgICAgICAgICAgaWYgKG5vZGVDYW52YXNPYmplY3RNb2RlID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERyYXcgd2lkZXIgbm9kZXMgYnkgMXB4IG9uIHNoYWRvdyBjYW52YXMgZm9yIG1vcmUgcHJlY2lzZSBob3ZlcmluZyAoZHVlIHRvIGJvdW5kYXJ5IGFudGktYWxpYXNpbmcpXG4gICAgICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgZ2V0VmFsKG5vZGUpIHx8IDEpKSAqIHN0YXRlLm5vZGVSZWxTaXplICsgcGFkQW1vdW50O1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHguYXJjKG5vZGUueCwgbm9kZS55LCByLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBnZXRDb2xvcihub2RlKSB8fCAncmdiYSgzMSwgMTIwLCAxODAsIDAuOTIpJztcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgIGlmIChzdGF0ZS5ub2RlQ2FudmFzT2JqZWN0ICYmIG5vZGVDYW52YXNPYmplY3RNb2RlID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgICAvLyBDdXN0b20gbm9kZSBhZnRlciBwYWludFxuICAgICAgICAgICAgc3RhdGUubm9kZUNhbnZhc09iamVjdChub2RlLCBzdGF0ZS5jdHgsIHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFpbnRMaW5rcygpIHtcbiAgICAgICAgdmFyIGdldFZpc2liaWxpdHkgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtWaXNpYmlsaXR5KTtcbiAgICAgICAgdmFyIGdldENvbG9yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rQ29sb3IpO1xuICAgICAgICB2YXIgZ2V0V2lkdGggPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtXaWR0aCk7XG4gICAgICAgIHZhciBnZXRMaW5lRGFzaCA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0xpbmVEYXNoKTtcbiAgICAgICAgdmFyIGdldEN1cnZhdHVyZSA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0N1cnZhdHVyZSk7XG4gICAgICAgIHZhciBnZXRMaW5rQ2FudmFzT2JqZWN0TW9kZSA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0NhbnZhc09iamVjdE1vZGUpO1xuICAgICAgICB2YXIgY3R4ID0gc3RhdGUuY3R4O1xuXG4gICAgICAgIC8vIERyYXcgd2lkZXIgbGluZXMgYnkgMnB4IG9uIHNoYWRvdyBjYW52YXMgZm9yIG1vcmUgcHJlY2lzZSBob3ZlcmluZyAoZHVlIHRvIGJvdW5kYXJ5IGFudGktYWxpYXNpbmcpXG4gICAgICAgIHZhciBwYWRBbW91bnQgPSBzdGF0ZS5pc1NoYWRvdyAqIDI7XG4gICAgICAgIHZhciB2aXNpYmxlTGlua3MgPSBzdGF0ZS5ncmFwaERhdGEubGlua3MuZmlsdGVyKGdldFZpc2liaWxpdHkpO1xuICAgICAgICB2aXNpYmxlTGlua3MuZm9yRWFjaChjYWxjTGlua0NvbnRyb2xQb2ludHMpOyAvLyBjYWxjdWxhdGUgY3VydmF0dXJlIGNvbnRyb2wgcG9pbnRzIGZvciBhbGwgdmlzaWJsZSBsaW5rc1xuXG4gICAgICAgIHZhciBiZWZvcmVDdXN0b21MaW5rcyA9IFtdLFxuICAgICAgICAgIGFmdGVyQ3VzdG9tTGlua3MgPSBbXSxcbiAgICAgICAgICBkZWZhdWx0UGFpbnRMaW5rcyA9IHZpc2libGVMaW5rcztcbiAgICAgICAgaWYgKHN0YXRlLmxpbmtDYW52YXNPYmplY3QpIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZUN1c3RvbUxpbmtzID0gW10sXG4gICAgICAgICAgICBvdGhlckN1c3RvbUxpbmtzID0gW107XG4gICAgICAgICAgdmlzaWJsZUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICBiZWZvcmU6IGJlZm9yZUN1c3RvbUxpbmtzLFxuICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXJDdXN0b21MaW5rcyxcbiAgICAgICAgICAgICAgcmVwbGFjZTogcmVwbGFjZUN1c3RvbUxpbmtzXG4gICAgICAgICAgICB9W2dldExpbmtDYW52YXNPYmplY3RNb2RlKGQpXSB8fCBvdGhlckN1c3RvbUxpbmtzKS5wdXNoKGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlZmF1bHRQYWludExpbmtzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShiZWZvcmVDdXN0b21MaW5rcyksIGFmdGVyQ3VzdG9tTGlua3MsIG90aGVyQ3VzdG9tTGlua3MpO1xuICAgICAgICAgIGJlZm9yZUN1c3RvbUxpbmtzID0gYmVmb3JlQ3VzdG9tTGlua3MuY29uY2F0KHJlcGxhY2VDdXN0b21MaW5rcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gbGluayBiZWZvcmUgcGFpbnRzXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGJlZm9yZUN1c3RvbUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubGlua0NhbnZhc09iamVjdChsaW5rLCBjdHgsIHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy8gQnVuZGxlIHN0cm9rZXMgcGVyIHVuaXF1ZSBjb2xvci93aWR0aC9kYXNoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAgICAgICAgdmFyIGxpbmtzUGVyQ29sb3IgPSBpbmRleEJ5KGRlZmF1bHRQYWludExpbmtzLCBbZ2V0Q29sb3IsIGdldFdpZHRoLCBnZXRMaW5lRGFzaF0pO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBPYmplY3QuZW50cmllcyhsaW5rc1BlckNvbG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBjb2xvciA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgbGlua3NQZXJXaWR0aCA9IF9yZWYyWzFdO1xuICAgICAgICAgIHZhciBsaW5lQ29sb3IgPSAhY29sb3IgfHwgY29sb3IgPT09ICd1bmRlZmluZWQnID8gJ3JnYmEoMCwwLDAsMC4xNSknIDogY29sb3I7XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMobGlua3NQZXJXaWR0aCkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICAgICAgd2lkdGggPSBfcmVmNFswXSxcbiAgICAgICAgICAgICAgbGluZXNQZXJMaW5lRGFzaCA9IF9yZWY0WzFdO1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9ICh3aWR0aCB8fCAxKSAvIHN0YXRlLmdsb2JhbFNjYWxlICsgcGFkQW1vdW50O1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobGluZXNQZXJMaW5lRGFzaCkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDIpO1xuICAgICAgICAgICAgICAgIF9yZWY2WzBdO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rcyA9IF9yZWY2WzFdO1xuICAgICAgICAgICAgICB2YXIgbGluZURhc2hTZWdtZW50cyA9IGdldExpbmVEYXNoKGxpbmtzWzBdKTtcbiAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbGluay5zb3VyY2U7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxpbmsudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCB8fCAhc3RhcnQuaGFzT3duUHJvcGVydHkoJ3gnKSB8fCAhZW5kLmhhc093blByb3BlcnR5KCd4JykpIHJldHVybjsgLy8gc2tpcCBpbnZhbGlkIGxpbmtcblxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBsaW5rLl9fY29udHJvbFBvaW50cztcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2xQb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFN0cmFpZ2h0IGxpbmVcbiAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZW5kLngsIGVuZC55KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gVXNlIHF1YWRyYXRpYyBjdXJ2ZXMgZm9yIHJlZ3VsYXIgbGluZXMgYW5kIGJlemllciBmb3IgbG9vcHNcbiAgICAgICAgICAgICAgICAgIGN0eFtjb250cm9sUG9pbnRzLmxlbmd0aCA9PT0gMiA/ICdxdWFkcmF0aWNDdXJ2ZVRvJyA6ICdiZXppZXJDdXJ2ZVRvJ10uYXBwbHkoY3R4LCBfdG9Db25zdW1hYmxlQXJyYXkoY29udHJvbFBvaW50cykuY29uY2F0KFtlbmQueCwgZW5kLnldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2hTZWdtZW50cyB8fCBbXSk7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAvLyBDdXN0b20gbGluayBhZnRlciBwYWludHNcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgYWZ0ZXJDdXN0b21MaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmxpbmtDYW52YXNPYmplY3QobGluaywgY3R4LCBzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgZnVuY3Rpb24gY2FsY0xpbmtDb250cm9sUG9pbnRzKGxpbmspIHtcbiAgICAgICAgICB2YXIgY3VydmF0dXJlID0gZ2V0Q3VydmF0dXJlKGxpbmspO1xuICAgICAgICAgIGlmICghY3VydmF0dXJlKSB7XG4gICAgICAgICAgICAvLyBzdHJhaWdodCBsaW5lXG4gICAgICAgICAgICBsaW5rLl9fY29udHJvbFBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlO1xuICAgICAgICAgIHZhciBlbmQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICB2YXIgbCA9IE1hdGguc3FydChNYXRoLnBvdyhlbmQueCAtIHN0YXJ0LngsIDIpICsgTWF0aC5wb3coZW5kLnkgLSBzdGFydC55LCAyKSk7IC8vIGxpbmUgbGVuZ3RoXG5cbiAgICAgICAgICBpZiAobCA+IDApIHtcbiAgICAgICAgICAgIHZhciBhID0gTWF0aC5hdGFuMihlbmQueSAtIHN0YXJ0LnksIGVuZC54IC0gc3RhcnQueCk7IC8vIGxpbmUgYW5nbGVcbiAgICAgICAgICAgIHZhciBkID0gbCAqIGN1cnZhdHVyZTsgLy8gY29udHJvbCBwb2ludCBkaXN0YW5jZVxuXG4gICAgICAgICAgICB2YXIgY3AgPSB7XG4gICAgICAgICAgICAgIC8vIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgeDogKHN0YXJ0LnggKyBlbmQueCkgLyAyICsgZCAqIE1hdGguY29zKGEgLSBNYXRoLlBJIC8gMiksXG4gICAgICAgICAgICAgIHk6IChzdGFydC55ICsgZW5kLnkpIC8gMiArIGQgKiBNYXRoLnNpbihhIC0gTWF0aC5QSSAvIDIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGluay5fX2NvbnRyb2xQb2ludHMgPSBbY3AueCwgY3AueV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNhbWUgcG9pbnQsIGRyYXcgYSBsb29wXG4gICAgICAgICAgICB2YXIgX2QgPSBjdXJ2YXR1cmUgKiA3MDtcbiAgICAgICAgICAgIGxpbmsuX19jb250cm9sUG9pbnRzID0gW2VuZC54LCBlbmQueSAtIF9kLCBlbmQueCArIF9kLCBlbmQueV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYWludEFycm93cygpIHtcbiAgICAgICAgdmFyIEFSUk9XX1dIX1JBVElPID0gMS42O1xuICAgICAgICB2YXIgQVJST1dfVkxFTl9SQVRJTyA9IDAuMjtcbiAgICAgICAgdmFyIGdldExlbmd0aCA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgpO1xuICAgICAgICB2YXIgZ2V0UmVsUG9zID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvcyk7XG4gICAgICAgIHZhciBnZXRWaXNpYmlsaXR5ID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rVmlzaWJpbGl0eSk7XG4gICAgICAgIHZhciBnZXRDb2xvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvciB8fCBzdGF0ZS5saW5rQ29sb3IpO1xuICAgICAgICB2YXIgZ2V0Tm9kZVZhbCA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZhbCk7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5maWx0ZXIoZ2V0VmlzaWJpbGl0eSkuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIHZhciBhcnJvd0xlbmd0aCA9IGdldExlbmd0aChsaW5rKTtcbiAgICAgICAgICBpZiAoIWFycm93TGVuZ3RoIHx8IGFycm93TGVuZ3RoIDwgMCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlO1xuICAgICAgICAgIHZhciBlbmQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICB2YXIgc3RhcnRSID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldE5vZGVWYWwoc3RhcnQpIHx8IDEpKSAqIHN0YXRlLm5vZGVSZWxTaXplO1xuICAgICAgICAgIHZhciBlbmRSID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldE5vZGVWYWwoZW5kKSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgICAgICB2YXIgYXJyb3dSZWxQb3MgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBnZXRSZWxQb3MobGluaykpKTtcbiAgICAgICAgICB2YXIgYXJyb3dDb2xvciA9IGdldENvbG9yKGxpbmspIHx8ICdyZ2JhKDAsMCwwLDAuMjgpJztcbiAgICAgICAgICB2YXIgYXJyb3dIYWxmV2lkdGggPSBhcnJvd0xlbmd0aCAvIEFSUk9XX1dIX1JBVElPIC8gMjtcblxuICAgICAgICAgIC8vIENvbnN0cnVjdCBiZXppZXIgZm9yIGN1cnZlZCBsaW5lc1xuICAgICAgICAgIHZhciBiekxpbmUgPSBsaW5rLl9fY29udHJvbFBvaW50cyAmJiBfY29uc3RydWN0KEJlemllciwgW3N0YXJ0LngsIHN0YXJ0LnldLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobGluay5fX2NvbnRyb2xQb2ludHMpLCBbZW5kLngsIGVuZC55XSkpO1xuICAgICAgICAgIHZhciBnZXRDb29yZHNBbG9uZ0xpbmUgPSBiekxpbmUgPyBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ6TGluZS5nZXQodCk7XG4gICAgICAgICAgfSAvLyBnZXQgcG9zaXRpb24gYWxvbmcgYmV6aWVyIGxpbmVcbiAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAvLyBzdHJhaWdodCBsaW5lOiBpbnRlcnBvbGF0ZSBsaW5lYXJseVxuICAgICAgICAgICAgICB4OiBzdGFydC54ICsgKGVuZC54IC0gc3RhcnQueCkgKiB0IHx8IDAsXG4gICAgICAgICAgICAgIHk6IHN0YXJ0LnkgKyAoZW5kLnkgLSBzdGFydC55KSAqIHQgfHwgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBsaW5lTGVuID0gYnpMaW5lID8gYnpMaW5lLmxlbmd0aCgpIDogTWF0aC5zcXJ0KE1hdGgucG93KGVuZC54IC0gc3RhcnQueCwgMikgKyBNYXRoLnBvdyhlbmQueSAtIHN0YXJ0LnksIDIpKTtcbiAgICAgICAgICB2YXIgcG9zQWxvbmdMaW5lID0gc3RhcnRSICsgYXJyb3dMZW5ndGggKyAobGluZUxlbiAtIHN0YXJ0UiAtIGVuZFIgLSBhcnJvd0xlbmd0aCkgKiBhcnJvd1JlbFBvcztcbiAgICAgICAgICB2YXIgYXJyb3dIZWFkID0gZ2V0Q29vcmRzQWxvbmdMaW5lKHBvc0Fsb25nTGluZSAvIGxpbmVMZW4pO1xuICAgICAgICAgIHZhciBhcnJvd1RhaWwgPSBnZXRDb29yZHNBbG9uZ0xpbmUoKHBvc0Fsb25nTGluZSAtIGFycm93TGVuZ3RoKSAvIGxpbmVMZW4pO1xuICAgICAgICAgIHZhciBhcnJvd1RhaWxWZXJ0ZXggPSBnZXRDb29yZHNBbG9uZ0xpbmUoKHBvc0Fsb25nTGluZSAtIGFycm93TGVuZ3RoICogKDEgLSBBUlJPV19WTEVOX1JBVElPKSkgLyBsaW5lTGVuKTtcbiAgICAgICAgICB2YXIgYXJyb3dUYWlsQW5nbGUgPSBNYXRoLmF0YW4yKGFycm93SGVhZC55IC0gYXJyb3dUYWlsLnksIGFycm93SGVhZC54IC0gYXJyb3dUYWlsLngpIC0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oYXJyb3dIZWFkLngsIGFycm93SGVhZC55KTtcbiAgICAgICAgICBjdHgubGluZVRvKGFycm93VGFpbC54ICsgYXJyb3dIYWxmV2lkdGggKiBNYXRoLmNvcyhhcnJvd1RhaWxBbmdsZSksIGFycm93VGFpbC55ICsgYXJyb3dIYWxmV2lkdGggKiBNYXRoLnNpbihhcnJvd1RhaWxBbmdsZSkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oYXJyb3dUYWlsVmVydGV4LngsIGFycm93VGFpbFZlcnRleC55KTtcbiAgICAgICAgICBjdHgubGluZVRvKGFycm93VGFpbC54IC0gYXJyb3dIYWxmV2lkdGggKiBNYXRoLmNvcyhhcnJvd1RhaWxBbmdsZSksIGFycm93VGFpbC55IC0gYXJyb3dIYWxmV2lkdGggKiBNYXRoLnNpbihhcnJvd1RhaWxBbmdsZSkpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBhcnJvd0NvbG9yO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFpbnRQaG90b25zKCkge1xuICAgICAgICB2YXIgZ2V0TnVtUGhvdG9ucyA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVzKTtcbiAgICAgICAgdmFyIGdldFNwZWVkID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVNwZWVkKTtcbiAgICAgICAgdmFyIGdldERpYW1ldGVyID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoKTtcbiAgICAgICAgdmFyIGdldFZpc2liaWxpdHkgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtWaXNpYmlsaXR5KTtcbiAgICAgICAgdmFyIGdldENvbG9yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yIHx8IHN0YXRlLmxpbmtDb2xvcik7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5maWx0ZXIoZ2V0VmlzaWJpbGl0eSkuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIHZhciBudW1DeWNsZVBob3RvbnMgPSBnZXROdW1QaG90b25zKGxpbmspO1xuICAgICAgICAgIGlmICghbGluay5oYXNPd25Qcm9wZXJ0eSgnX19waG90b25zJykgfHwgIWxpbmsuX19waG90b25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlO1xuICAgICAgICAgIHZhciBlbmQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICB2YXIgcGFydGljbGVTcGVlZCA9IGdldFNwZWVkKGxpbmspO1xuICAgICAgICAgIHZhciBwaG90b25zID0gbGluay5fX3Bob3RvbnMgfHwgW107XG4gICAgICAgICAgdmFyIHBob3RvblIgPSBNYXRoLm1heCgwLCBnZXREaWFtZXRlcihsaW5rKSAvIDIpIC8gTWF0aC5zcXJ0KHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgICB2YXIgcGhvdG9uQ29sb3IgPSBnZXRDb2xvcihsaW5rKSB8fCAncmdiYSgwLDAsMCwwLjI4KSc7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHBob3RvbkNvbG9yO1xuXG4gICAgICAgICAgLy8gQ29uc3RydWN0IGJlemllciBmb3IgY3VydmVkIGxpbmVzXG4gICAgICAgICAgdmFyIGJ6TGluZSA9IGxpbmsuX19jb250cm9sUG9pbnRzID8gX2NvbnN0cnVjdChCZXppZXIsIFtzdGFydC54LCBzdGFydC55XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxpbmsuX19jb250cm9sUG9pbnRzKSwgW2VuZC54LCBlbmQueV0pKSA6IG51bGw7XG4gICAgICAgICAgdmFyIGN5Y2xlUGhvdG9uSWR4ID0gMDtcbiAgICAgICAgICB2YXIgbmVlZHNDbGVhbnVwID0gZmFsc2U7IC8vIHdoZXRoZXIgc29tZSBwaG90b25zIG5lZWQgdG8gYmUgcmVtb3ZlZCBmcm9tIGxpc3RcbiAgICAgICAgICBwaG90b25zLmZvckVhY2goZnVuY3Rpb24gKHBob3Rvbikge1xuICAgICAgICAgICAgdmFyIHNpbmdsZUhvcCA9ICEhcGhvdG9uLl9fc2luZ2xlSG9wO1xuICAgICAgICAgICAgaWYgKCFwaG90b24uaGFzT3duUHJvcGVydHkoJ19fcHJvZ3Jlc3NSYXRpbycpKSB7XG4gICAgICAgICAgICAgIHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gPSBzaW5nbGVIb3AgPyAwIDogY3ljbGVQaG90b25JZHggLyBudW1DeWNsZVBob3RvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhc2luZ2xlSG9wICYmIGN5Y2xlUGhvdG9uSWR4Kys7IC8vIGluY3JlYXNlIHJlZ3VsYXIgcGhvdG9uIGluZGV4XG5cbiAgICAgICAgICAgIHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gKz0gcGFydGljbGVTcGVlZDtcbiAgICAgICAgICAgIGlmIChwaG90b24uX19wcm9ncmVzc1JhdGlvID49IDEpIHtcbiAgICAgICAgICAgICAgaWYgKCFzaW5nbGVIb3ApIHtcbiAgICAgICAgICAgICAgICBwaG90b24uX19wcm9ncmVzc1JhdGlvID0gcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyAlIDE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVlZHNDbGVhbnVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwaG90b25Qb3NSYXRpbyA9IHBob3Rvbi5fX3Byb2dyZXNzUmF0aW87XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gYnpMaW5lID8gYnpMaW5lLmdldChwaG90b25Qb3NSYXRpbykgLy8gZ2V0IHBvc2l0aW9uIGFsb25nIGJlemllciBsaW5lXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZTogaW50ZXJwb2xhdGUgbGluZWFybHlcbiAgICAgICAgICAgICAgeDogc3RhcnQueCArIChlbmQueCAtIHN0YXJ0LngpICogcGhvdG9uUG9zUmF0aW8gfHwgMCxcbiAgICAgICAgICAgICAgeTogc3RhcnQueSArIChlbmQueSAtIHN0YXJ0LnkpICogcGhvdG9uUG9zUmF0aW8gfHwgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5hcmMoY29vcmRzLngsIGNvb3Jkcy55LCBwaG90b25SLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobmVlZHNDbGVhbnVwKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhwaXJlZCBzaW5nbGUgaG9wIHBob3RvbnNcbiAgICAgICAgICAgIGxpbmsuX19waG90b25zID0gbGluay5fX3Bob3RvbnMuZmlsdGVyKGZ1bmN0aW9uIChwaG90b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFwaG90b24uX19zaW5nbGVIb3AgfHwgcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA8PSAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVtaXRQYXJ0aWNsZTogZnVuY3Rpb24gZW1pdFBhcnRpY2xlKHN0YXRlLCBsaW5rKSB7XG4gICAgICBpZiAobGluaykge1xuICAgICAgICAhbGluay5fX3Bob3RvbnMgJiYgKGxpbmsuX19waG90b25zID0gW10pO1xuICAgICAgICBsaW5rLl9fcGhvdG9ucy5wdXNoKHtcbiAgICAgICAgICBfX3NpbmdsZUhvcDogdHJ1ZVxuICAgICAgICB9KTsgLy8gYWRkIGEgc2luZ2xlIGhvcCBwYXJ0aWNsZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LFxuICBzdGF0ZUluaXQ6IGZ1bmN0aW9uIHN0YXRlSW5pdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9yY2VMYXlvdXQ6IGZvcmNlU2ltdWxhdGlvbigpLmZvcmNlKCdsaW5rJywgZm9yY2VMaW5rKCkpLmZvcmNlKCdjaGFyZ2UnLCBmb3JjZU1hbnlCb2R5KCkpLmZvcmNlKCdjZW50ZXInLCBmb3JjZUNlbnRlcigpKS5mb3JjZSgnZGFnUmFkaWFsJywgbnVsbCkuc3RvcCgpLFxuICAgICAgZW5naW5lUnVubmluZzogZmFsc2VcbiAgICB9O1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KGNhbnZhc0N0eCwgc3RhdGUpIHtcbiAgICAvLyBNYWluIGNhbnZhcyBvYmplY3QgdG8gbWFuaXB1bGF0ZVxuICAgIHN0YXRlLmN0eCA9IGNhbnZhc0N0eDtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoc3RhdGUpIHtcbiAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gZmFsc2U7IC8vIFBhdXNlIHNpbXVsYXRpb25cbiAgICBzdGF0ZS5vblVwZGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5ub2RlQXV0b0NvbG9yQnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEF1dG8gYWRkIGNvbG9yIHRvIHVuY29sb3JlZCBub2Rlc1xuICAgICAgYXV0b0NvbG9yT2JqZWN0cyhzdGF0ZS5ncmFwaERhdGEubm9kZXMsIGFjY2Vzc29yRm4oc3RhdGUubm9kZUF1dG9Db2xvckJ5KSwgc3RhdGUubm9kZUNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmxpbmtBdXRvQ29sb3JCeSAhPT0gbnVsbCkge1xuICAgICAgLy8gQXV0byBhZGQgY29sb3IgdG8gdW5jb2xvcmVkIGxpbmtzXG4gICAgICBhdXRvQ29sb3JPYmplY3RzKHN0YXRlLmdyYXBoRGF0YS5saW5rcywgYWNjZXNzb3JGbihzdGF0ZS5saW5rQXV0b0NvbG9yQnkpLCBzdGF0ZS5saW5rQ29sb3IpO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGxpbmtzXG4gICAgc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgIGxpbmsuc291cmNlID0gbGlua1tzdGF0ZS5saW5rU291cmNlXTtcbiAgICAgIGxpbmsudGFyZ2V0ID0gbGlua1tzdGF0ZS5saW5rVGFyZ2V0XTtcbiAgICB9KTtcblxuICAgIC8vIEZlZWQgZGF0YSB0byBmb3JjZS1kaXJlY3RlZCBsYXlvdXRcbiAgICBzdGF0ZS5mb3JjZUxheW91dC5zdG9wKCkuYWxwaGEoMSkgLy8gcmUtaGVhdCB0aGUgc2ltdWxhdGlvblxuICAgIC5ub2RlcyhzdGF0ZS5ncmFwaERhdGEubm9kZXMpO1xuXG4gICAgLy8gYWRkIGxpbmtzIChpZiBsaW5rIGZvcmNlIGlzIHN0aWxsIGFjdGl2ZSlcbiAgICB2YXIgbGlua0ZvcmNlID0gc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoJ2xpbmsnKTtcbiAgICBpZiAobGlua0ZvcmNlKSB7XG4gICAgICBsaW5rRm9yY2UuaWQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbc3RhdGUubm9kZUlkXTtcbiAgICAgIH0pLmxpbmtzKHN0YXRlLmdyYXBoRGF0YS5saW5rcyk7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgZGFnIGZvcmNlIGNvbnN0cmFpbnRzXG4gICAgdmFyIG5vZGVEZXB0aHMgPSBzdGF0ZS5kYWdNb2RlICYmIGdldERhZ0RlcHRocyhzdGF0ZS5ncmFwaERhdGEsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZVtzdGF0ZS5ub2RlSWRdO1xuICAgIH0sIHtcbiAgICAgIG5vZGVGaWx0ZXI6IHN0YXRlLmRhZ05vZGVGaWx0ZXIsXG4gICAgICBvbkxvb3BFcnJvcjogc3RhdGUub25EYWdFcnJvciB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgICB2YXIgbWF4RGVwdGggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LnZhbHVlcyhub2RlRGVwdGhzIHx8IFtdKSkpO1xuICAgIHZhciBkYWdMZXZlbERpc3RhbmNlID0gc3RhdGUuZGFnTGV2ZWxEaXN0YW5jZSB8fCBzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoIC8gKG1heERlcHRoIHx8IDEpICogREFHX0xFVkVMX05PREVfUkFUSU8gKiAoWydyYWRpYWxpbicsICdyYWRpYWxvdXQnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSA/IDAuNyA6IDEpO1xuXG4gICAgLy8gRml4IG5vZGVzIHRvIHgseSBmb3IgZGFnIG1vZGVcbiAgICBpZiAoc3RhdGUuZGFnTW9kZSkge1xuICAgICAgdmFyIGdldEZGbiA9IGZ1bmN0aW9uIGdldEZGbihmaXgsIGludmVydCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gIWZpeCA/IHVuZGVmaW5lZCA6IChub2RlRGVwdGhzW25vZGVbc3RhdGUubm9kZUlkXV0gLSBtYXhEZXB0aCAvIDIpICogZGFnTGV2ZWxEaXN0YW5jZSAqIChpbnZlcnQgPyAtMSA6IDEpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBmeEZuID0gZ2V0RkZuKFsnbHInLCAncmwnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSwgc3RhdGUuZGFnTW9kZSA9PT0gJ3JsJyk7XG4gICAgICB2YXIgZnlGbiA9IGdldEZGbihbJ3RkJywgJ2J1J10uaW5kZXhPZihzdGF0ZS5kYWdNb2RlKSAhPT0gLTEsIHN0YXRlLmRhZ01vZGUgPT09ICdidScpO1xuICAgICAgc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmZpbHRlcihzdGF0ZS5kYWdOb2RlRmlsdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUuZnggPSBmeEZuKG5vZGUpO1xuICAgICAgICBub2RlLmZ5ID0gZnlGbihub2RlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVzZSByYWRpYWwgZm9yY2UgZm9yIHJhZGlhbCBkYWdzXG4gICAgc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoJ2RhZ1JhZGlhbCcsIFsncmFkaWFsaW4nLCAncmFkaWFsb3V0J10uaW5kZXhPZihzdGF0ZS5kYWdNb2RlKSAhPT0gLTEgPyBmb3JjZVJhZGlhbChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIG5vZGVEZXB0aCA9IG5vZGVEZXB0aHNbbm9kZVtzdGF0ZS5ub2RlSWRdXSB8fCAtMTtcbiAgICAgIHJldHVybiAoc3RhdGUuZGFnTW9kZSA9PT0gJ3JhZGlhbGluJyA/IG1heERlcHRoIC0gbm9kZURlcHRoIDogbm9kZURlcHRoKSAqIGRhZ0xldmVsRGlzdGFuY2U7XG4gICAgfSkuc3RyZW5ndGgoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5kYWdOb2RlRmlsdGVyKG5vZGUpID8gMSA6IDA7XG4gICAgfSkgOiBudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLndhcm11cFRpY2tzICYmICEoc3RhdGUuZDNBbHBoYU1pbiA+IDAgJiYgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGEoKSA8IHN0YXRlLmQzQWxwaGFNaW4pOyBpKyspIHtcbiAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LnRpY2soKTtcbiAgICB9IC8vIEluaXRpYWwgdGlja3MgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlbmRlclxuXG4gICAgdGhpcy5yZXNldENvdW50ZG93bigpO1xuICAgIHN0YXRlLm9uRmluaXNoVXBkYXRlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBsaW5rS2Fwc3VsZSAoa2Fwc3VsZVByb3BOYW1lcywga2Fwc3VsZVR5cGUpIHtcbiAgdmFyIHByb3BOYW1lcyA9IGthcHN1bGVQcm9wTmFtZXMgaW5zdGFuY2VvZiBBcnJheSA/IGthcHN1bGVQcm9wTmFtZXMgOiBba2Fwc3VsZVByb3BOYW1lc107XG4gIHZhciBkdW1teUsgPSBuZXcga2Fwc3VsZVR5cGUoKTsgLy8gVG8gZXh0cmFjdCBkZWZhdWx0c1xuICBkdW1teUsuX2Rlc3RydWN0b3IgJiYgZHVtbXlLLl9kZXN0cnVjdG9yKCk7XG4gIHJldHVybiB7XG4gICAgbGlua1Byb3A6IGZ1bmN0aW9uIGxpbmtQcm9wKHByb3ApIHtcbiAgICAgIC8vIGxpbmsgcHJvcGVydHkgY29uZmlnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBcImRlZmF1bHRcIjogZHVtbXlLW3Byb3BdKCksXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2LCBzdGF0ZSkge1xuICAgICAgICAgIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlW3Byb3BOYW1lXVtwcm9wXSh2KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBsaW5rTWV0aG9kOiBmdW5jdGlvbiBsaW5rTWV0aG9kKG1ldGhvZCkge1xuICAgICAgLy8gbGluayBtZXRob2QgcGFzcy10aHJvdWdoXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0dXJuVmFscyA9IFtdO1xuICAgICAgICBwcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICB2YXIga2Fwc3VsZUluc3RhbmNlID0gc3RhdGVbcHJvcE5hbWVdO1xuICAgICAgICAgIHZhciByZXR1cm5WYWwgPSBrYXBzdWxlSW5zdGFuY2VbbWV0aG9kXS5hcHBseShrYXBzdWxlSW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgIGlmIChyZXR1cm5WYWwgIT09IGthcHN1bGVJbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuVmFscy5wdXNoKHJldHVyblZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHMubGVuZ3RoID8gcmV0dXJuVmFsc1swXSA6IHRoaXM7IC8vIGNoYWluIGJhc2VkIG9uIHRoZSBwYXJlbnQgb2JqZWN0LCBub3QgdGhlIGlubmVyIGthcHN1bGVcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG52YXIgSE9WRVJfQ0FOVkFTX1RIUk9UVExFX0RFTEFZID0gODAwOyAvLyBtcyB0byB0aHJvdHRsZSBzaGFkb3cgY2FudmFzIHVwZGF0ZXMgZm9yIHBlcmYgaW1wcm92ZW1lbnRcbnZhciBaT09NMk5PREVTX0ZBQ1RPUiA9IDQ7XG5cbi8vIEV4cG9zZSBjb25maWcgZnJvbSBmb3JjZUdyYXBoXG52YXIgYmluZEZHID0gbGlua0thcHN1bGUoJ2ZvcmNlR3JhcGgnLCBDYW52YXNGb3JjZUdyYXBoKTtcbnZhciBiaW5kQm90aCA9IGxpbmtLYXBzdWxlKFsnZm9yY2VHcmFwaCcsICdzaGFkb3dHcmFwaCddLCBDYW52YXNGb3JjZUdyYXBoKTtcbnZhciBsaW5rZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBfdG9Db25zdW1hYmxlQXJyYXkoWydub2RlQ29sb3InLCAnbm9kZUF1dG9Db2xvckJ5JywgJ25vZGVDYW52YXNPYmplY3QnLCAnbm9kZUNhbnZhc09iamVjdE1vZGUnLCAnbGlua0NvbG9yJywgJ2xpbmtBdXRvQ29sb3JCeScsICdsaW5rTGluZURhc2gnLCAnbGlua1dpZHRoJywgJ2xpbmtDYW52YXNPYmplY3QnLCAnbGlua0NhbnZhc09iamVjdE1vZGUnLCAnbGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgnLCAnbGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvcicsICdsaW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvcycsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZCcsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3InLCAnZGFnTW9kZScsICdkYWdMZXZlbERpc3RhbmNlJywgJ2RhZ05vZGVGaWx0ZXInLCAnb25EYWdFcnJvcicsICdkM0FscGhhTWluJywgJ2QzQWxwaGFEZWNheScsICdkM1ZlbG9jaXR5RGVjYXknLCAnd2FybXVwVGlja3MnLCAnY29vbGRvd25UaWNrcycsICdjb29sZG93blRpbWUnLCAnb25FbmdpbmVUaWNrJywgJ29uRW5naW5lU3RvcCddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kRkcubGlua1Byb3AocCkpO1xufSkpLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoWydub2RlUmVsU2l6ZScsICdub2RlSWQnLCAnbm9kZVZhbCcsICdub2RlVmlzaWJpbGl0eScsICdsaW5rU291cmNlJywgJ2xpbmtUYXJnZXQnLCAnbGlua1Zpc2liaWxpdHknLCAnbGlua0N1cnZhdHVyZSddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kQm90aC5saW5rUHJvcChwKSk7XG59KSkpKTtcbnZhciBsaW5rZWRNZXRob2RzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIF90b0NvbnN1bWFibGVBcnJheShbJ2QzRm9yY2UnLCAnZDNSZWhlYXRTaW11bGF0aW9uJywgJ2VtaXRQYXJ0aWNsZSddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kRkcubGlua01ldGhvZChwKSk7XG59KSkpO1xuZnVuY3Rpb24gYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUuY2FudmFzKSB7XG4gICAgdmFyIGN1cldpZHRoID0gc3RhdGUuY2FudmFzLndpZHRoO1xuICAgIHZhciBjdXJIZWlnaHQgPSBzdGF0ZS5jYW52YXMuaGVpZ2h0O1xuICAgIGlmIChjdXJXaWR0aCA9PT0gMzAwICYmIGN1ckhlaWdodCA9PT0gMTUwKSB7XG4gICAgICAvLyBEZWZhdWx0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICBjdXJXaWR0aCA9IGN1ckhlaWdodCA9IDA7XG4gICAgfVxuICAgIHZhciBweFNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87IC8vIDIgb24gcmV0aW5hIGRpc3BsYXlzXG4gICAgY3VyV2lkdGggLz0gcHhTY2FsZTtcbiAgICBjdXJIZWlnaHQgLz0gcHhTY2FsZTtcblxuICAgIC8vIFJlc2l6ZSBjYW52YXNlc1xuICAgIFtzdGF0ZS5jYW52YXMsIHN0YXRlLnNoYWRvd0NhbnZhc10uZm9yRWFjaChmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICAvLyBFbGVtZW50IHNpemVcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHN0YXRlLndpZHRoLCBcInB4XCIpO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KHN0YXRlLmhlaWdodCwgXCJweFwiKTtcblxuICAgICAgLy8gTWVtb3J5IHNpemUgKHNjYWxlZCB0byBhdm9pZCBibHVycmluZXNzKVxuICAgICAgY2FudmFzLndpZHRoID0gc3RhdGUud2lkdGggKiBweFNjYWxlO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHN0YXRlLmhlaWdodCAqIHB4U2NhbGU7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlIHN5c3RlbSB0byB1c2UgY3NzIHBpeGVscyAob24gaW5pdCBvbmx5KVxuICAgICAgaWYgKCFjdXJXaWR0aCAmJiAhY3VySGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnNjYWxlKHB4U2NhbGUsIHB4U2NhbGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVsYXRpdmUgY2VudGVyIHBhbm5pbmcgYmFzZWQgb24gMCwwXG4gICAgdmFyIGsgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICBzdGF0ZS56b29tLnRyYW5zbGF0ZUJ5KHN0YXRlLnpvb20uX19iYXNlRWxlbSwgKHN0YXRlLndpZHRoIC0gY3VyV2lkdGgpIC8gMiAvIGssIChzdGF0ZS5oZWlnaHQgLSBjdXJIZWlnaHQpIC8gMiAvIGspO1xuICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm0oY3R4KSB7XG4gIHZhciBweFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGN0eC5zZXRUcmFuc2Zvcm0ocHhSYXRpbywgMCwgMCwgcHhSYXRpbywgMCwgMCk7XG59XG5mdW5jdGlvbiBjbGVhckNhbnZhcyhjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgY3R4LnNhdmUoKTtcbiAgcmVzZXRUcmFuc2Zvcm0oY3R4KTsgLy8gcmVzZXQgdHJhbnNmb3JtXG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7IC8vcmVzdG9yZSB0cmFuc2Zvcm1zXG59XG5cbi8vXG5cbnZhciBmb3JjZUdyYXBoID0gS2Fwc3VsZSh7XG4gIHByb3BzOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgd2lkdGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShfLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgXCJkZWZhdWx0XCI6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShfLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGdyYXBoRGF0YToge1xuICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICBsaW5rczogW11cbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZCwgc3RhdGUpIHtcbiAgICAgICAgW3tcbiAgICAgICAgICB0eXBlOiAnTm9kZScsXG4gICAgICAgICAgb2JqczogZC5ub2Rlc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogJ0xpbmsnLFxuICAgICAgICAgIG9ianM6IGQubGlua3NcbiAgICAgICAgfV0uZm9yRWFjaChoZXhJbmRleCk7XG4gICAgICAgIHN0YXRlLmZvcmNlR3JhcGguZ3JhcGhEYXRhKGQpO1xuICAgICAgICBzdGF0ZS5zaGFkb3dHcmFwaC5ncmFwaERhdGEoZCk7XG4gICAgICAgIGZ1bmN0aW9uIGhleEluZGV4KF9yZWY0KSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBfcmVmNC50eXBlLFxuICAgICAgICAgICAgb2JqcyA9IF9yZWY0Lm9ianM7XG4gICAgICAgICAgb2Jqcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmICghZC5oYXNPd25Qcm9wZXJ0eSgnX19pbmRleENvbG9yJykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgdmFyIGN1ciA9IHN0YXRlLmNvbG9yVHJhY2tlci5sb29rdXAoZC5fX2luZGV4Q29sb3IpO1xuICAgICAgICAgICAgcmV0dXJuICFjdXIgfHwgIWN1ci5oYXNPd25Qcm9wZXJ0eSgnZCcpIHx8IGN1ci5kICE9PSBkO1xuICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIG9iamVjdCBsb29rdXAgY29sb3JcbiAgICAgICAgICAgIGQuX19pbmRleENvbG9yID0gc3RhdGUuY29sb3JUcmFja2VyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgZDogZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoY29sb3IsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmNhbnZhcyAmJiBjb2xvciAmJiAoc3RhdGUuY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvcik7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG5vZGVMYWJlbDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICduYW1lJyxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBub2RlUG9pbnRlckFyZWFQYWludDoge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHBhaW50Rm4sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLm5vZGVDYW52YXNPYmplY3QoIXBhaW50Rm4gPyBudWxsIDogZnVuY3Rpb24gKG5vZGUsIGN0eCwgZ2xvYmFsU2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gcGFpbnRGbihub2RlLCBub2RlLl9faW5kZXhDb2xvciwgY3R4LCBnbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcyAmJiBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcygpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rUG9pbnRlckFyZWFQYWludDoge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHBhaW50Rm4sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLmxpbmtDYW52YXNPYmplY3QoIXBhaW50Rm4gPyBudWxsIDogZnVuY3Rpb24gKGxpbmssIGN0eCwgZ2xvYmFsU2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gcGFpbnRGbihsaW5rLCBsaW5rLl9faW5kZXhDb2xvciwgY3R4LCBnbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcyAmJiBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcygpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rTGFiZWw6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnbmFtZScsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua0hvdmVyUHJlY2lzaW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogNCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBtaW5ab29tOiB7XG4gICAgICBcImRlZmF1bHRcIjogMC4wMSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShtaW5ab29tLCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS56b29tLnNjYWxlRXh0ZW50KFttaW5ab29tLCBzdGF0ZS56b29tLnNjYWxlRXh0ZW50KClbMV1dKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbWF4Wm9vbToge1xuICAgICAgXCJkZWZhdWx0XCI6IDEwMDAsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UobWF4Wm9vbSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuem9vbS5zY2FsZUV4dGVudChbc3RhdGUuem9vbS5zY2FsZUV4dGVudCgpWzBdLCBtYXhab29tXSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGVuYWJsZU5vZGVEcmFnOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmFibGVab29tSW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGVuYWJsZVBhbkludGVyYWN0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmFibGVab29tUGFuSW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIHRvIGJlIGRlcHJlY2F0ZWRcbiAgICBlbmFibGVQb2ludGVySW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKF8sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmhvdmVyT2JqID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgYXV0b1BhdXNlUmVkcmF3OiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVEcmFnOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVEcmFnRW5kOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTm9kZVJpZ2h0Q2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVIb3Zlcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTGlua0NsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25MaW5rUmlnaHRDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTGlua0hvdmVyOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25CYWNrZ3JvdW5kQ2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkJhY2tncm91bmRSaWdodENsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25ab29tOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25ab29tRW5kOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25SZW5kZXJGcmFtZVByZToge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uUmVuZGVyRnJhbWVQb3N0OiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH1cbiAgfSwgbGlua2VkUHJvcHMpLFxuICBhbGlhc2VzOiB7XG4gICAgLy8gUHJvcCBuYW1lcyBzdXBwb3J0ZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgc3RvcEFuaW1hdGlvbjogJ3BhdXNlQW5pbWF0aW9uJ1xuICB9LFxuICBtZXRob2RzOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgZ3JhcGgyU2NyZWVuQ29vcmRzOiBmdW5jdGlvbiBncmFwaDJTY3JlZW5Db29yZHMoc3RhdGUsIHgsIHkpIHtcbiAgICAgIHZhciB0ID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHQuayArIHQueCxcbiAgICAgICAgeTogeSAqIHQuayArIHQueVxuICAgICAgfTtcbiAgICB9LFxuICAgIHNjcmVlbjJHcmFwaENvb3JkczogZnVuY3Rpb24gc2NyZWVuMkdyYXBoQ29vcmRzKHN0YXRlLCB4LCB5KSB7XG4gICAgICB2YXIgdCA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6ICh4IC0gdC54KSAvIHQuayxcbiAgICAgICAgeTogKHkgLSB0LnkpIC8gdC5rXG4gICAgICB9O1xuICAgIH0sXG4gICAgY2VudGVyQXQ6IGZ1bmN0aW9uIGNlbnRlckF0KHN0YXRlLCB4LCB5LCB0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgIGlmICghc3RhdGUuY2FudmFzKSByZXR1cm4gbnVsbDsgLy8gbm8gY2FudmFzIHlldFxuXG4gICAgICAvLyBzZXR0ZXJcbiAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQgfHwgeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaW5hbFBvcyA9IE9iamVjdC5hc3NpZ24oe30sIHggIT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgICB4OiB4XG4gICAgICAgIH0gOiB7fSwgeSAhPT0gdW5kZWZpbmVkID8ge1xuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSA6IHt9KTtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBubyBhbmltYXRpb25cbiAgICAgICAgICBzZXRDZW50ZXIoZmluYWxQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ldyBUV0VFTi5Ud2VlbihnZXRDZW50ZXIoKSkudG8oZmluYWxQb3MsIHRyYW5zaXRpb25EdXJhdGlvbikuZWFzaW5nKFRXRUVOLkVhc2luZy5RdWFkcmF0aWMuT3V0KS5vblVwZGF0ZShzZXRDZW50ZXIpLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldHRlclxuICAgICAgcmV0dXJuIGdldENlbnRlcigpO1xuXG4gICAgICAvL1xuXG4gICAgICBmdW5jdGlvbiBnZXRDZW50ZXIoKSB7XG4gICAgICAgIHZhciB0ID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IChzdGF0ZS53aWR0aCAvIDIgLSB0LngpIC8gdC5rLFxuICAgICAgICAgIHk6IChzdGF0ZS5oZWlnaHQgLyAyIC0gdC55KSAvIHQua1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2V0Q2VudGVyKF9yZWY1KSB7XG4gICAgICAgIHZhciB4ID0gX3JlZjUueCxcbiAgICAgICAgICB5ID0gX3JlZjUueTtcbiAgICAgICAgc3RhdGUuem9vbS50cmFuc2xhdGVUbyhzdGF0ZS56b29tLl9fYmFzZUVsZW0sIHggPT09IHVuZGVmaW5lZCA/IGdldENlbnRlcigpLnggOiB4LCB5ID09PSB1bmRlZmluZWQgPyBnZXRDZW50ZXIoKS55IDogeSk7XG4gICAgICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uIHpvb20oc3RhdGUsIGssIHRyYW5zaXRpb25EdXJhdGlvbikge1xuICAgICAgaWYgKCFzdGF0ZS5jYW52YXMpIHJldHVybiBudWxsOyAvLyBubyBjYW52YXMgeWV0XG5cbiAgICAgIC8vIHNldHRlclxuICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXRyYW5zaXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIC8vIG5vIGFuaW1hdGlvblxuICAgICAgICAgIHNldFpvb20oayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3IFRXRUVOLlR3ZWVuKHtcbiAgICAgICAgICAgIGs6IGdldFpvb20oKVxuICAgICAgICAgIH0pLnRvKHtcbiAgICAgICAgICAgIGs6IGtcbiAgICAgICAgICB9LCB0cmFuc2l0aW9uRHVyYXRpb24pLmVhc2luZyhUV0VFTi5FYXNpbmcuUXVhZHJhdGljLk91dCkub25VcGRhdGUoZnVuY3Rpb24gKF9yZWY2KSB7XG4gICAgICAgICAgICB2YXIgayA9IF9yZWY2Lms7XG4gICAgICAgICAgICByZXR1cm4gc2V0Wm9vbShrKTtcbiAgICAgICAgICB9KS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXR0ZXJcbiAgICAgIHJldHVybiBnZXRab29tKCk7XG5cbiAgICAgIC8vXG5cbiAgICAgIGZ1bmN0aW9uIGdldFpvb20oKSB7XG4gICAgICAgIHJldHVybiB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNldFpvb20oaykge1xuICAgICAgICBzdGF0ZS56b29tLnNjYWxlVG8oc3RhdGUuem9vbS5fX2Jhc2VFbGVtLCBrKTtcbiAgICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgem9vbVRvRml0OiBmdW5jdGlvbiB6b29tVG9GaXQoc3RhdGUpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTA7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYmJveEFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBiYm94QXJnc1tfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0R3JhcGhCYm94LmFwcGx5KHRoaXMsIGJib3hBcmdzKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgICAgeDogKGJib3gueFswXSArIGJib3gueFsxXSkgLyAyLFxuICAgICAgICAgIHk6IChiYm94LnlbMF0gKyBiYm94LnlbMV0pIC8gMlxuICAgICAgICB9O1xuICAgICAgICB2YXIgem9vbUsgPSBNYXRoLm1heCgxZS0xMiwgTWF0aC5taW4oMWUxMiwgKHN0YXRlLndpZHRoIC0gcGFkZGluZyAqIDIpIC8gKGJib3gueFsxXSAtIGJib3gueFswXSksIChzdGF0ZS5oZWlnaHQgLSBwYWRkaW5nICogMikgLyAoYmJveC55WzFdIC0gYmJveC55WzBdKSkpO1xuICAgICAgICB0aGlzLmNlbnRlckF0KGNlbnRlci54LCBjZW50ZXIueSwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy56b29tKHpvb21LLCB0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRHcmFwaEJib3g6IGZ1bmN0aW9uIGdldEdyYXBoQmJveChzdGF0ZSkge1xuICAgICAgdmFyIG5vZGVGaWx0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgdmFyIGdldFZhbCA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZhbCk7XG4gICAgICB2YXIgZ2V0UiA9IGZ1bmN0aW9uIGdldFIobm9kZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldFZhbChub2RlKSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgIH07XG4gICAgICB2YXIgbm9kZXNQb3MgPSBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmlsdGVyKG5vZGVGaWx0ZXIpLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IG5vZGUueCxcbiAgICAgICAgICB5OiBub2RlLnksXG4gICAgICAgICAgcjogZ2V0Uihub2RlKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gIW5vZGVzUG9zLmxlbmd0aCA/IG51bGwgOiB7XG4gICAgICAgIHg6IFttaW4obm9kZXNQb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueCAtIG5vZGUucjtcbiAgICAgICAgfSksIG1heChub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS54ICsgbm9kZS5yO1xuICAgICAgICB9KV0sXG4gICAgICAgIHk6IFttaW4obm9kZXNQb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueSAtIG5vZGUucjtcbiAgICAgICAgfSksIG1heChub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS55ICsgbm9kZS5yO1xuICAgICAgICB9KV1cbiAgICAgIH07XG4gICAgfSxcbiAgICBwYXVzZUFuaW1hdGlvbjogZnVuY3Rpb24gcGF1c2VBbmltYXRpb24oc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCk7XG4gICAgICAgIHN0YXRlLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVzdW1lQW5pbWF0aW9uOiBmdW5jdGlvbiByZXN1bWVBbmltYXRpb24oc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ3ljbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX2Rlc3RydWN0b3I6IGZ1bmN0aW9uIF9kZXN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5wYXVzZUFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5ncmFwaERhdGEoe1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGxpbmtzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBsaW5rZWRNZXRob2RzKSxcbiAgc3RhdGVJbml0OiBmdW5jdGlvbiBzdGF0ZUluaXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RTZXRab29tOiAxLFxuICAgICAgem9vbTogem9vbSgpLFxuICAgICAgZm9yY2VHcmFwaDogbmV3IENhbnZhc0ZvcmNlR3JhcGgoKSxcbiAgICAgIHNoYWRvd0dyYXBoOiBuZXcgQ2FudmFzRm9yY2VHcmFwaCgpLmNvb2xkb3duVGlja3MoMCkubm9kZUNvbG9yKCdfX2luZGV4Q29sb3InKS5saW5rQ29sb3IoJ19faW5kZXhDb2xvcicpLmlzU2hhZG93KHRydWUpLFxuICAgICAgY29sb3JUcmFja2VyOiBuZXcgQ29sb3JUcmFja2VyKCkgLy8gaW5kZXhlZCBvYmplY3RzIGZvciByZ2IgbG9va3VwXG4gICAgfTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChkb21Ob2RlLCBzdGF0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gV2lwZSBET01cbiAgICBkb21Ob2RlLmlubmVySFRNTCA9ICcnO1xuXG4gICAgLy8gQ29udGFpbmVyIGFuY2hvciBmb3IgY2FudmFzIGFuZCB0b29sdGlwXG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmb3JjZS1ncmFwaC1jb250YWluZXInKTtcbiAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIGRvbU5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBzdGF0ZS5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBpZiAoc3RhdGUuYmFja2dyb3VuZENvbG9yKSBzdGF0ZS5jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9IHN0YXRlLmJhY2tncm91bmRDb2xvcjtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3RhdGUuY2FudmFzKTtcbiAgICBzdGF0ZS5zaGFkb3dDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIC8vIFNob3cgc2hhZG93IGNhbnZhc1xuICAgIC8vc3RhdGUuc2hhZG93Q2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAvL3N0YXRlLnNoYWRvd0NhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgLy9zdGF0ZS5zaGFkb3dDYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAvL2NvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0ZS5zaGFkb3dDYW52YXMpO1xuXG4gICAgdmFyIGN0eCA9IHN0YXRlLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBzaGFkb3dDdHggPSBzdGF0ZS5zaGFkb3dDYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgcG9pbnRlclBvcyA9IHtcbiAgICAgIHg6IC0xZTEyLFxuICAgICAgeTogLTFlMTJcbiAgICB9O1xuICAgIHZhciBnZXRPYmpVbmRlclBvaW50ZXIgPSBmdW5jdGlvbiBnZXRPYmpVbmRlclBvaW50ZXIoKSB7XG4gICAgICB2YXIgb2JqID0gbnVsbDtcbiAgICAgIHZhciBweFNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICB2YXIgcHggPSBwb2ludGVyUG9zLnggPiAwICYmIHBvaW50ZXJQb3MueSA+IDAgPyBzaGFkb3dDdHguZ2V0SW1hZ2VEYXRhKHBvaW50ZXJQb3MueCAqIHB4U2NhbGUsIHBvaW50ZXJQb3MueSAqIHB4U2NhbGUsIDEsIDEpIDogbnVsbDtcbiAgICAgIC8vIExvb2t1cCBvYmplY3QgcGVyIHBpeGVsIGNvbG9yXG4gICAgICBweCAmJiAob2JqID0gc3RhdGUuY29sb3JUcmFja2VyLmxvb2t1cChweC5kYXRhKSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBTZXR1cCBub2RlIGRyYWcgaW50ZXJhY3Rpb25cbiAgICBzZWxlY3Qoc3RhdGUuY2FudmFzKS5jYWxsKGRyYWcoKS5zdWJqZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3RhdGUuZW5hYmxlTm9kZURyYWcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gZ2V0T2JqVW5kZXJQb2ludGVyKCk7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai50eXBlID09PSAnTm9kZScgPyBvYmouZCA6IG51bGw7IC8vIE9ubHkgZHJhZyBub2Rlc1xuICAgIH0pLm9uKCdzdGFydCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIG9iaiA9IGV2LnN1YmplY3Q7XG4gICAgICBvYmouX19pbml0aWFsRHJhZ1BvcyA9IHtcbiAgICAgICAgeDogb2JqLngsXG4gICAgICAgIHk6IG9iai55LFxuICAgICAgICBmeDogb2JqLmZ4LFxuICAgICAgICBmeTogb2JqLmZ5XG4gICAgICB9O1xuXG4gICAgICAvLyBrZWVwIGVuZ2luZSBydW5uaW5nIGF0IGxvdyBpbnRlbnNpdHkgdGhyb3VnaG91dCBkcmFnXG4gICAgICBpZiAoIWV2LmFjdGl2ZSkge1xuICAgICAgICBvYmouZnggPSBvYmoueDtcbiAgICAgICAgb2JqLmZ5ID0gb2JqLnk7IC8vIEZpeCBwb2ludHNcbiAgICAgIH1cblxuICAgICAgLy8gZHJhZyBjdXJzb3JcbiAgICAgIHN0YXRlLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdncmFiYmFibGUnKTtcbiAgICB9KS5vbignZHJhZycsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIG9iaiA9IGV2LnN1YmplY3Q7XG4gICAgICB2YXIgaW5pdFBvcyA9IG9iai5fX2luaXRpYWxEcmFnUG9zO1xuICAgICAgdmFyIGRyYWdQb3MgPSBldjtcbiAgICAgIHZhciBrID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpLms7XG4gICAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgICB4OiBpbml0UG9zLnggKyAoZHJhZ1Bvcy54IC0gaW5pdFBvcy54KSAvIGsgLSBvYmoueCxcbiAgICAgICAgeTogaW5pdFBvcy55ICsgKGRyYWdQb3MueSAtIGluaXRQb3MueSkgLyBrIC0gb2JqLnlcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vdmUgZngvZnkgKGFuZCB4L3kpIG9mIG5vZGVzIGJhc2VkIG9uIHRoZSBzY2FsZWQgZHJhZyBkaXN0YW5jZSBzaW5jZSB0aGUgZHJhZyBzdGFydFxuICAgICAgWyd4JywgJ3knXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBvYmpbXCJmXCIuY29uY2F0KGMpXSA9IG9ialtjXSA9IGluaXRQb3NbY10gKyAoZHJhZ1Bvc1tjXSAtIGluaXRQb3NbY10pIC8gaztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcmV2ZW50IGZyZWV6ZSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgc3RhdGUuZm9yY2VHcmFwaC5kM0FscGhhVGFyZ2V0KDAuMykgLy8ga2VlcCBlbmdpbmUgcnVubmluZyBhdCBsb3cgaW50ZW5zaXR5IHRocm91Z2hvdXQgZHJhZ1xuICAgICAgLnJlc2V0Q291bnRkb3duKCk7IC8vIHByZXZlbnQgZnJlZXplIHdoaWxlIGRyYWdnaW5nXG5cbiAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIG9iai5fX2RyYWdnZWQgPSB0cnVlO1xuICAgICAgc3RhdGUub25Ob2RlRHJhZyhvYmosIHRyYW5zbGF0ZSk7XG4gICAgfSkub24oJ2VuZCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIG9iaiA9IGV2LnN1YmplY3Q7XG4gICAgICB2YXIgaW5pdFBvcyA9IG9iai5fX2luaXRpYWxEcmFnUG9zO1xuICAgICAgdmFyIHRyYW5zbGF0ZSA9IHtcbiAgICAgICAgeDogb2JqLnggLSBpbml0UG9zLngsXG4gICAgICAgIHk6IG9iai55IC0gaW5pdFBvcy55XG4gICAgICB9O1xuICAgICAgaWYgKGluaXRQb3MuZnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmouZnggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaW5pdFBvcy5meSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iai5meSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvYmouX19pbml0aWFsRHJhZ1BvcztcbiAgICAgIGlmIChzdGF0ZS5mb3JjZUdyYXBoLmQzQWxwaGFUYXJnZXQoKSkge1xuICAgICAgICBzdGF0ZS5mb3JjZUdyYXBoLmQzQWxwaGFUYXJnZXQoMCkgLy8gcmVsZWFzZSBlbmdpbmUgbG93IGludGVuc2l0eVxuICAgICAgICAucmVzZXRDb3VudGRvd24oKTsgLy8gbGV0IHRoZSBlbmdpbmUgcmVhZGp1c3QgYWZ0ZXIgcmVsZWFzaW5nIGZpeGVkIG5vZGVzXG4gICAgICB9XG5cbiAgICAgIC8vIGRyYWcgY3Vyc29yXG4gICAgICBzdGF0ZS5jYW52YXMuY2xhc3NMaXN0LnJlbW92ZSgnZ3JhYmJhYmxlJyk7XG4gICAgICBzdGF0ZS5pc1BvaW50ZXJEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgaWYgKG9iai5fX2RyYWdnZWQpIHtcbiAgICAgICAgZGVsZXRlIG9iai5fX2RyYWdnZWQ7XG4gICAgICAgIHN0YXRlLm9uTm9kZURyYWdFbmQob2JqLCB0cmFuc2xhdGUpO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIFNldHVwIHpvb20gLyBwYW4gaW50ZXJhY3Rpb25cbiAgICBzdGF0ZS56b29tKHN0YXRlLnpvb20uX19iYXNlRWxlbSA9IHNlbGVjdChzdGF0ZS5jYW52YXMpKTsgLy8gQXR0YWNoIGNvbnRyb2xsaW5nIGVsZW0gZm9yIGVhc3kgYWNjZXNzXG5cbiAgICBzdGF0ZS56b29tLl9fYmFzZUVsZW0ub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKTsgLy8gRGlzYWJsZSBkb3VibGUtY2xpY2sgdG8gem9vbVxuXG4gICAgc3RhdGUuem9vbS5maWx0ZXIoZnVuY3Rpb24gKGV2KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyBkaXNhYmxlIHpvb20gaW50ZXJhY3Rpb25cbiAgICAgICAgIWV2LmJ1dHRvbiAmJiBzdGF0ZS5lbmFibGVab29tUGFuSW50ZXJhY3Rpb24gJiYgKHN0YXRlLmVuYWJsZVpvb21JbnRlcmFjdGlvbiB8fCBldi50eXBlICE9PSAnd2hlZWwnKSAmJiAoc3RhdGUuZW5hYmxlUGFuSW50ZXJhY3Rpb24gfHwgZXYudHlwZSA9PT0gJ3doZWVsJylcbiAgICAgICk7XG4gICAgfSkub24oJ3pvb20nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciB0ID0gZXYudHJhbnNmb3JtO1xuICAgICAgW2N0eCwgc2hhZG93Q3R4XS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJlc2V0VHJhbnNmb3JtKGMpO1xuICAgICAgICBjLnRyYW5zbGF0ZSh0LngsIHQueSk7XG4gICAgICAgIGMuc2NhbGUodC5rLCB0LmspO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZS5vblpvb20gJiYgc3RhdGUub25ab29tKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0KSwgX3RoaXMuY2VudGVyQXQoKSkpOyAvLyByZXBvcnQgeCx5IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcyBjZW50ZXJcbiAgICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB9KS5vbignZW5kJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICByZXR1cm4gc3RhdGUub25ab29tRW5kICYmIHN0YXRlLm9uWm9vbUVuZChfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZXYudHJhbnNmb3JtKSwgX3RoaXMuY2VudGVyQXQoKSkpO1xuICAgIH0pO1xuICAgIGFkanVzdENhbnZhc1NpemUoc3RhdGUpO1xuICAgIHN0YXRlLmZvcmNlR3JhcGgub25OZWVkc1JlZHJhdyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIH0pLm9uRmluaXNoVXBkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHJlLXpvb20sIGlmIHN0aWxsIGluIGRlZmF1bHQgcG9zaXRpb24gKG5vdCB1c2VyIG1vZGlmaWVkKVxuICAgICAgaWYgKHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKS5rID09PSBzdGF0ZS5sYXN0U2V0Wm9vbSAmJiBzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlLnpvb20uc2NhbGVUbyhzdGF0ZS56b29tLl9fYmFzZUVsZW0sIHN0YXRlLmxhc3RTZXRab29tID0gWk9PTTJOT0RFU19GQUNUT1IgLyBNYXRoLmNicnQoc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZXR1cCB0b29sdGlwXG4gICAgdmFyIHRvb2xUaXBFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdG9vbFRpcEVsZW0uY2xhc3NMaXN0LmFkZCgnZ3JhcGgtdG9vbHRpcCcpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b29sVGlwRWxlbSk7XG5cbiAgICAvLyBDYXB0dXJlIHBvaW50ZXIgY29vcmRzIG9uIG1vdmUgb3IgdG91Y2hzdGFydFxuICAgIFsncG9pbnRlcm1vdmUnLCAncG9pbnRlcmRvd24nXS5mb3JFYWNoKGZ1bmN0aW9uIChldlR5cGUpIHtcbiAgICAgIHJldHVybiBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldlR5cGUsIGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoZXZUeXBlID09PSAncG9pbnRlcmRvd24nKSB7XG4gICAgICAgICAgc3RhdGUuaXNQb2ludGVyUHJlc3NlZCA9IHRydWU7IC8vIHRyYWNrIGNsaWNrIHN0YXRlXG4gICAgICAgICAgc3RhdGUucG9pbnRlckRvd25FdmVudCA9IGV2O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGV0ZWN0IHBvaW50ZXIgZHJhZyBvbiBjYW52YXMgcGFuXG4gICAgICAgICFzdGF0ZS5pc1BvaW50ZXJEcmFnZ2luZyAmJiBldi50eXBlID09PSAncG9pbnRlcm1vdmUnICYmIHN0YXRlLm9uQmFja2dyb3VuZENsaWNrIC8vIG9ubHkgYm90aGVyIGRldGVjdGluZyBkcmFncyB0aGlzIHdheSBpZiBiYWNrZ3JvdW5kIGNsaWNrcyBhcmUgZW5hYmxlZCAoc28gdGhleSBkb24ndCB0cmlnZ2VyIGFjY2lkZW50YWxseSBvbiBjYW52YXMgcGFubmluZylcbiAgICAgICAgJiYgKGV2LnByZXNzdXJlID4gMCB8fCBzdGF0ZS5pc1BvaW50ZXJQcmVzc2VkKSAvLyBldi5wcmVzc3VyZSBhbHdheXMgMCBvbiBTYWZhcmksIHNvIHdlIHVzZSB0aGUgaXNQb2ludGVyUHJlc3NlZCB0cmFja2VyXG4gICAgICAgICYmIChldi5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJyB8fCBldi5tb3ZlbWVudFggPT09IHVuZGVmaW5lZCB8fCBbZXYubW92ZW1lbnRYLCBldi5tb3ZlbWVudFldLnNvbWUoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobSkgPiAxO1xuICAgICAgICB9KSkgLy8gcmVsYXggZHJhZyB0cmlnZ2VyIHNlbnNpdGl2aXR5IG9uIHRvdWNoIGV2ZW50c1xuICAgICAgICAmJiAoc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPSB0cnVlKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXIgcG9zXG4gICAgICAgIHZhciBvZmZzZXQgPSBnZXRPZmZzZXQoY29udGFpbmVyKTtcbiAgICAgICAgcG9pbnRlclBvcy54ID0gZXYucGFnZVggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgcG9pbnRlclBvcy55ID0gZXYucGFnZVkgLSBvZmZzZXQudG9wO1xuXG4gICAgICAgIC8vIE1vdmUgdG9vbHRpcFxuICAgICAgICB0b29sVGlwRWxlbS5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdChwb2ludGVyUG9zLnksIFwicHhcIik7XG4gICAgICAgIHRvb2xUaXBFbGVtLnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChwb2ludGVyUG9zLngsIFwicHhcIik7XG5cbiAgICAgICAgLy8gYWRqdXN0IGhvcml6b250YWwgcG9zaXRpb24gdG8gbm90IGV4Y2VlZCBjYW52YXMgYm91bmRhcmllc1xuICAgICAgICB0b29sVGlwRWxlbS5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZSgtXCIuY29uY2F0KHBvaW50ZXJQb3MueCAvIHN0YXRlLndpZHRoICogMTAwLCBcIiUsIFwiKS5jb25jYXQoXG4gICAgICAgIC8vIGZsaXAgdG8gYWJvdmUgaWYgbmVhciBib3R0b21cbiAgICAgICAgc3RhdGUuaGVpZ2h0IC0gcG9pbnRlclBvcy55IDwgMTAwID8gJ2NhbGMoLTEwMCUgLSA4cHgpJyA6ICcyMXB4JywgXCIpXCIpO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHNjcm9sbFRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHNjcm9sbExlZnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIGNsaWNrL3RvdWNoIGV2ZW50cyBvbiBub2Rlcy9saW5rc1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHN0YXRlLmlzUG9pbnRlclByZXNzZWQgPSBmYWxzZTtcbiAgICAgIGlmIChzdGF0ZS5pc1BvaW50ZXJEcmFnZ2luZykge1xuICAgICAgICBzdGF0ZS5pc1BvaW50ZXJEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47IC8vIGRvbid0IHRyaWdnZXIgY2xpY2sgZXZlbnRzIGFmdGVyIHBvaW50ZXIgZHJhZyAocGFuIC8gbm9kZSBkcmFnIGZ1bmN0aW9uYWxpdHkpXG4gICAgICB9XG4gICAgICB2YXIgY2JFdmVudHMgPSBbZXYsIHN0YXRlLnBvaW50ZXJEb3duRXZlbnRdO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjbGljayBldmVudHMgYXN5bmNocm9ub3VzbHksIHRvIGFsbG93IGhvdmVyT2JqIHRvIGJlIHNldCAob24gZnJhbWUpXG4gICAgICAgIGlmIChldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAvLyBtb3VzZSBsZWZ0LWNsaWNrIG9yIHRvdWNoXG4gICAgICAgICAgaWYgKHN0YXRlLmhvdmVyT2JqKSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBzdGF0ZVtcIm9uXCIuY29uY2F0KHN0YXRlLmhvdmVyT2JqLnR5cGUsIFwiQ2xpY2tcIildO1xuICAgICAgICAgICAgZm4gJiYgZm4uYXBwbHkodm9pZCAwLCBbc3RhdGUuaG92ZXJPYmouZF0uY29uY2F0KGNiRXZlbnRzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLm9uQmFja2dyb3VuZENsaWNrICYmIHN0YXRlLm9uQmFja2dyb3VuZENsaWNrLmFwcGx5KHN0YXRlLCBjYkV2ZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChldi5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICAvLyBtb3VzZSByaWdodC1jbGlja1xuICAgICAgICAgIGlmIChzdGF0ZS5ob3Zlck9iaikge1xuICAgICAgICAgICAgdmFyIF9mbiA9IHN0YXRlW1wib25cIi5jb25jYXQoc3RhdGUuaG92ZXJPYmoudHlwZSwgXCJSaWdodENsaWNrXCIpXTtcbiAgICAgICAgICAgIF9mbiAmJiBfZm4uYXBwbHkodm9pZCAwLCBbc3RhdGUuaG92ZXJPYmouZF0uY29uY2F0KGNiRXZlbnRzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLm9uQmFja2dyb3VuZFJpZ2h0Q2xpY2sgJiYgc3RhdGUub25CYWNrZ3JvdW5kUmlnaHRDbGljay5hcHBseShzdGF0ZSwgY2JFdmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKCFzdGF0ZS5vbkJhY2tncm91bmRSaWdodENsaWNrICYmICFzdGF0ZS5vbk5vZGVSaWdodENsaWNrICYmICFzdGF0ZS5vbkxpbmtSaWdodENsaWNrKSByZXR1cm4gdHJ1ZTsgLy8gZGVmYXVsdCBjb250ZXh0bWVudSBiZWhhdmlvclxuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICBzdGF0ZS5mb3JjZUdyYXBoKGN0eCk7XG4gICAgc3RhdGUuc2hhZG93R3JhcGgoc2hhZG93Q3R4KTtcblxuICAgIC8vXG5cbiAgICB2YXIgcmVmcmVzaFNoYWRvd0NhbnZhcyA9IHRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHdpcGUgY2FudmFzXG4gICAgICBjbGVhckNhbnZhcyhzaGFkb3dDdHgsIHN0YXRlLndpZHRoLCBzdGF0ZS5oZWlnaHQpO1xuXG4gICAgICAvLyBBZGp1c3QgbGluayBob3ZlciBhcmVhXG4gICAgICBzdGF0ZS5zaGFkb3dHcmFwaC5saW5rV2lkdGgoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc29yRm4oc3RhdGUubGlua1dpZHRoKShsKSArIHN0YXRlLmxpbmtIb3ZlclByZWNpc2lvbjtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZWRyYXdcbiAgICAgIHZhciB0ID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpO1xuICAgICAgc3RhdGUuc2hhZG93R3JhcGguZ2xvYmFsU2NhbGUodC5rKS50aWNrRnJhbWUoKTtcbiAgICB9LCBIT1ZFUl9DQU5WQVNfVEhST1RUTEVfREVMQVkpO1xuICAgIHN0YXRlLmZsdXNoU2hhZG93Q2FudmFzID0gcmVmcmVzaFNoYWRvd0NhbnZhcy5mbHVzaDsgLy8gaG9vayB0byBpbW1lZGlhdGVseSBpbnZva2Ugc2hhZG93IGNhbnZhcyBwYWludFxuXG4gICAgLy8gS2ljay1vZmYgcmVuZGVyZXJcbiAgICAodGhpcy5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgLy8gSUlGRVxuICAgICAgdmFyIGRvUmVkcmF3ID0gIXN0YXRlLmF1dG9QYXVzZVJlZHJhdyB8fCAhIXN0YXRlLm5lZWRzUmVkcmF3IHx8IHN0YXRlLmZvcmNlR3JhcGguaXNFbmdpbmVSdW5uaW5nKCkgfHwgc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuX19waG90b25zICYmIGQuX19waG90b25zLmxlbmd0aDtcbiAgICAgIH0pO1xuICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSBmYWxzZTtcbiAgICAgIGlmIChzdGF0ZS5lbmFibGVQb2ludGVySW50ZXJhY3Rpb24pIHtcbiAgICAgICAgLy8gVXBkYXRlIHRvb2x0aXAgYW5kIHRyaWdnZXIgb25Ib3ZlciBldmVudHNcbiAgICAgICAgdmFyIG9iaiA9ICFzdGF0ZS5pc1BvaW50ZXJEcmFnZ2luZyA/IGdldE9ialVuZGVyUG9pbnRlcigpIDogbnVsbDsgLy8gZG9uJ3QgaG92ZXIgZHVyaW5nIGRyYWdcbiAgICAgICAgaWYgKG9iaiAhPT0gc3RhdGUuaG92ZXJPYmopIHtcbiAgICAgICAgICB2YXIgcHJldk9iaiA9IHN0YXRlLmhvdmVyT2JqO1xuICAgICAgICAgIHZhciBwcmV2T2JqVHlwZSA9IHByZXZPYmogPyBwcmV2T2JqLnR5cGUgOiBudWxsO1xuICAgICAgICAgIHZhciBvYmpUeXBlID0gb2JqID8gb2JqLnR5cGUgOiBudWxsO1xuICAgICAgICAgIGlmIChwcmV2T2JqVHlwZSAmJiBwcmV2T2JqVHlwZSAhPT0gb2JqVHlwZSkge1xuICAgICAgICAgICAgLy8gSG92ZXIgb3V0XG4gICAgICAgICAgICB2YXIgZm4gPSBzdGF0ZVtcIm9uXCIuY29uY2F0KHByZXZPYmpUeXBlLCBcIkhvdmVyXCIpXTtcbiAgICAgICAgICAgIGZuICYmIGZuKG51bGwsIHByZXZPYmouZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmpUeXBlKSB7XG4gICAgICAgICAgICAvLyBIb3ZlciBpblxuICAgICAgICAgICAgdmFyIF9mbjIgPSBzdGF0ZVtcIm9uXCIuY29uY2F0KG9ialR5cGUsIFwiSG92ZXJcIildO1xuICAgICAgICAgICAgX2ZuMiAmJiBfZm4yKG9iai5kLCBwcmV2T2JqVHlwZSA9PT0gb2JqVHlwZSA/IHByZXZPYmouZCA6IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdG9vbHRpcENvbnRlbnQgPSBvYmogPyBhY2Nlc3NvckZuKHN0YXRlW1wiXCIuY29uY2F0KG9iai50eXBlLnRvTG93ZXJDYXNlKCksIFwiTGFiZWxcIildKShvYmouZCkgfHwgJycgOiAnJztcbiAgICAgICAgICB0b29sVGlwRWxlbS5zdHlsZS52aXNpYmlsaXR5ID0gdG9vbHRpcENvbnRlbnQgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcbiAgICAgICAgICB0b29sVGlwRWxlbS5pbm5lckhUTUwgPSB0b29sdGlwQ29udGVudDtcblxuICAgICAgICAgIC8vIHNldCBwb2ludGVyIGlmIGhvdmVyZWQgb2JqZWN0IGlzIGNsaWNrYWJsZVxuICAgICAgICAgIHN0YXRlLmNhbnZhcy5jbGFzc0xpc3Rbb2JqICYmIHN0YXRlW1wib25cIi5jb25jYXQob2JqVHlwZSwgXCJDbGlja1wiKV0gfHwgIW9iaiAmJiBzdGF0ZS5vbkJhY2tncm91bmRDbGljayA/ICdhZGQnIDogJ3JlbW92ZSddKCdjbGlja2FibGUnKTtcbiAgICAgICAgICBzdGF0ZS5ob3Zlck9iaiA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBkb1JlZHJhdyAmJiByZWZyZXNoU2hhZG93Q2FudmFzKCk7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZWRyYXcpIHtcbiAgICAgICAgLy8gV2lwZSBjYW52YXNcbiAgICAgICAgY2xlYXJDYW52YXMoY3R4LCBzdGF0ZS53aWR0aCwgc3RhdGUuaGVpZ2h0KTtcblxuICAgICAgICAvLyBGcmFtZSBjeWNsZVxuICAgICAgICB2YXIgZ2xvYmFsU2NhbGUgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICAgICAgc3RhdGUub25SZW5kZXJGcmFtZVByZSAmJiBzdGF0ZS5vblJlbmRlckZyYW1lUHJlKGN0eCwgZ2xvYmFsU2NhbGUpO1xuICAgICAgICBzdGF0ZS5mb3JjZUdyYXBoLmdsb2JhbFNjYWxlKGdsb2JhbFNjYWxlKS50aWNrRnJhbWUoKTtcbiAgICAgICAgc3RhdGUub25SZW5kZXJGcmFtZVBvc3QgJiYgc3RhdGUub25SZW5kZXJGcmFtZVBvc3QoY3R4LCBnbG9iYWxTY2FsZSk7XG4gICAgICB9XG4gICAgICBUV0VFTi51cGRhdGUoKTsgLy8gdXBkYXRlIGNhbnZhcyBhbmltYXRpb24gdHdlZW5zXG5cbiAgICAgIHN0YXRlLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIH0pKCk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlRm4oc3RhdGUpIHt9XG59KTtcblxuZXhwb3J0IHsgZm9yY2VHcmFwaCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/force-graph@1.43.5/node_modules/force-graph/dist/force-graph.mjs\n");

/***/ })

};
;