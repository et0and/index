"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@musicorum+lastfm@0.3.1";
exports.ids = ["vendor-chunks/@musicorum+lastfm@0.3.1"];
exports.modules = {

/***/ "(action-browser)/./node_modules/.pnpm/@musicorum+lastfm@0.3.1/node_modules/@musicorum/lastfm/dist/LastClient.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@musicorum+lastfm@0.3.1/node_modules/@musicorum/lastfm/dist/LastClient.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LastClient: () => (/* binding */ LastClient)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n\n\nclass LastfmError extends Error {\n    response;\n    error;\n    constructor(response) {\n        super(response.message);\n        this.response = response;\n        this.error = response.error;\n    }\n}\n/**\n * Sources: {@link https://lastfm-docs.github.io/api-docs/codes/} and {@link https://www.last.fm/api/errorcodes}\n */\nvar LastfmErrorCode;\n(function (LastfmErrorCode) {\n    /**\n     * This service does not exist\n     */\n    LastfmErrorCode[LastfmErrorCode[\"SERVICE_UNAVAILABLE\"] = 2] = \"SERVICE_UNAVAILABLE\";\n    /**\n     *  No method with that name in this package\n     */\n    LastfmErrorCode[LastfmErrorCode[\"INVALID_METHOD\"] = 3] = \"INVALID_METHOD\";\n    /**\n     * You do not have permissions to access the service\n     */\n    LastfmErrorCode[LastfmErrorCode[\"AUTHENTICATION_FAILED\"] = 4] = \"AUTHENTICATION_FAILED\";\n    /**\n     * This service doesn't exist in that format\n     */\n    LastfmErrorCode[LastfmErrorCode[\"INVALID_RESPONSE_FORMAT\"] = 5] = \"INVALID_RESPONSE_FORMAT\";\n    /**\n     * Your request is missing a required parameter\n     */\n    LastfmErrorCode[LastfmErrorCode[\"INVALID_PARAMETER\"] = 6] = \"INVALID_PARAMETER\";\n    /**\n     * Invalid resource specified\n     */\n    LastfmErrorCode[LastfmErrorCode[\"INVALID_RESOURCE\"] = 7] = \"INVALID_RESOURCE\";\n    /**\n     * Most likely the backend service failed. Please try again.\n     */\n    LastfmErrorCode[LastfmErrorCode[\"OPERATION_FAILED\"] = 8] = \"OPERATION_FAILED\";\n    /**\n     *  Invalid session key - Please re-authenticate\n     */\n    LastfmErrorCode[LastfmErrorCode[\"INVALID_SERSSION_TOKEN\"] = 9] = \"INVALID_SERSSION_TOKEN\";\n    /**\n     * You must be granted with a valid key by last.fm\n     */\n    LastfmErrorCode[LastfmErrorCode[\"INVALID_API_TOKEN\"] = 10] = \"INVALID_API_TOKEN\";\n    /**\n     * This service is temporary offline. Try again later.\n     */\n    LastfmErrorCode[LastfmErrorCode[\"SERVICE_OFFLINE\"] = 11] = \"SERVICE_OFFLINE\";\n    /**\n     * Invalid method signature supplied\n     */\n    LastfmErrorCode[LastfmErrorCode[\"INVALID_SIGNATURE\"] = 13] = \"INVALID_SIGNATURE\";\n    /**\n     * This token has not been authorized\n     */\n    LastfmErrorCode[LastfmErrorCode[\"UNAUTHORIZED_TOKEN\"] = 14] = \"UNAUTHORIZED_TOKEN\";\n    /**\n     * The service is temporarily unavailable, please try again.\n     */\n    LastfmErrorCode[LastfmErrorCode[\"TEMPORARY_ERROR\"] = 16] = \"TEMPORARY_ERROR\";\n    /**\n     * User requires to be logged in to use this method\n     * This may be caused when trying to get some user's data with restricted privicy\n     */\n    LastfmErrorCode[LastfmErrorCode[\"REQUIRES_LOGIN\"] = 17] = \"REQUIRES_LOGIN\";\n    /**\n     * This application is not allowed to make requests to the web services\n     */\n    LastfmErrorCode[LastfmErrorCode[\"API_KEY_SUSPENDED\"] = 26] = \"API_KEY_SUSPENDED\";\n    /**\n     * This type of request is no longer supported\n     */\n    LastfmErrorCode[LastfmErrorCode[\"DEPRECATED\"] = 27] = \"DEPRECATED\";\n    /**\n     * Your IP has made too many requests in a short period\n     */\n    LastfmErrorCode[LastfmErrorCode[\"RATE_LIMIT_EXCEEDED\"] = 29] = \"RATE_LIMIT_EXCEEDED\";\n})(LastfmErrorCode || (LastfmErrorCode = {}));\n\n/**\n * Paginated results for a resource. This can be used to get specific pages or multiple pages\n */\nclass PaginatedResult {\n    requester;\n    totalPages;\n    totalResults;\n    perPage;\n    pages = [];\n    constructor(attr, requester) {\n        this.requester = requester;\n        this.totalPages = parseInt(attr.totalPages);\n        this.perPage = parseInt(attr.perPage);\n        this.totalResults = parseInt(attr.total);\n    }\n    /**\n     * Appends contents of a page to this paginated result\n     * @param page The page number of the contents to append\n     * @param items The resources of that page to append\n     * @returns This current paginated result\n     */\n    appendPage(page, items) {\n        // page index is converted to array index subtracting one number\n        // e.g. page 1 reffers to index 0\n        this.pages[--page] = items;\n        return this;\n    }\n    /**\n     * Get the contents from a page\n     * @param page The page to get the contents from. Page numbers start from 1\n     * @returns A list of the resources of that specific page\n     */\n    getPage(page) {\n        return this.pages[--page];\n    }\n    /**\n     * Get all contents fetched from this paginated result\n     * @returns All contents of all fetched pages. Note that missing pages will be ignoed\n     */\n    getAll() {\n        return this.pages.flat();\n    }\n    /**\n     * Fetches content from a page from the API, if it wasn't fetched yet\n     * @param page The page number to fetch content from. Page numbers start from 1\n     * @param force This will force to fetch that page, even if it's already fetched\n     * @returns The results from that page.\n     */\n    async fetchPage(page, force = false) {\n        if (this.pages[page - 1] && !force) {\n            return this.getPage(page);\n        }\n        const results = await this.requester(page);\n        this.appendPage(page, results);\n        return results;\n    }\n}\n\nfunction parseLastfmImages(images) {\n    return images\n        .filter((i) => !!i['#text'])\n        .map((i) => ({\n        size: i.size,\n        url: i['#text']\n    }));\n}\nfunction parseLastfmPagination(original) {\n    return {\n        page: parseInt(original.page),\n        totalPages: parseInt(original.totalPages),\n        perPage: parseInt(original.perPage),\n        total: parseInt(original.total)\n    };\n}\n\nclass User {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    async getInfo(user) {\n        const original = await this.client.request('user.getInfo', { user });\n        return {\n            name: original.user.name,\n            realName: original.user.name,\n            age: parseInt(original.user.age),\n            playCount: parseInt(original.user.playcount),\n            country: original.user.country,\n            registered: new Date(parseInt(original.user.registered.unixtime) * 1000),\n            gender: original.user.gender,\n            subscriber: original.user.subscriber === '1',\n            images: parseLastfmImages(original.user.image),\n            url: original.user.url\n        };\n    }\n    async getRecentTracks(user, params) {\n        const stringParams = {\n            user,\n            limit: (params?.limit ?? 50).toString(),\n            page: (params?.page ?? 1).toString(),\n            extended: params?.extended === true ? '1' : '0'\n        };\n        if (params?.from) {\n            stringParams.from = Math.round(params.from.getTime() / 1000).toString();\n        }\n        if (params?.to) {\n            stringParams.to = Math.round(params.to.getTime() / 1000).toString();\n        }\n        const response = await this.client.request('user.getRecentTracks', stringParams);\n        const trackList = Array.isArray(response.recenttracks.track)\n            ? response.recenttracks.track\n            : [response.recenttracks.track];\n        const tracks = trackList.map((track) => ({\n            name: track.name,\n            mbid: track.mbid ?? undefined,\n            streamable: track.streamable == '1',\n            artist: {\n                name: track.artist.name || track.artist['#text'],\n                mbid: track.artist.mbid ?? undefined\n            },\n            images: parseLastfmImages(track.image),\n            album: {\n                name: track.album['#text'],\n                mbid: track.album.mbid ?? undefined\n            },\n            url: track.url,\n            date: track.date?.uts\n                ? new Date(parseInt(track.date.uts) * 1000)\n                : undefined,\n            nowPlaying: track['@attr']?.nowplaying === 'true',\n            loved: 'loved' in track ? track.loved === '1' : undefined\n        }));\n        return {\n            tracks,\n            attr: response.recenttracks['@attr']\n        };\n    }\n    async getRecentTracksPaginated(user, params) {\n        const metadataResponse = await this.getRecentTracks(user, params);\n        const paginated = new PaginatedResult(metadataResponse.attr, async (page) => {\n            const tracks = await this.getRecentTracks(user, {\n                ...params,\n                page\n            }).then((r) => r.tracks);\n            // skip first item if its now playing and not at first page, to prevent duplicates\n            return page !== 1 && tracks[0].nowPlaying ? tracks.slice(1) : tracks;\n        });\n        paginated.appendPage(params?.page ?? 1, metadataResponse.tracks);\n        return paginated;\n    }\n    async getTopAlbums(user, params) {\n        const response = await this.client.request('user.getTopAlbums', {\n            ...params,\n            user\n        });\n        const albums = response.topalbums.album.map((a) => ({\n            name: a.name,\n            artist: a.artist,\n            playCount: parseInt(a.playcount),\n            rank: parseInt(a['@attr'].rank),\n            mbid: a.mbid,\n            images: parseLastfmImages(a.image)\n        }));\n        return {\n            albums,\n            pagination: parseLastfmPagination(response.topalbums['@attr'])\n        };\n    }\n    async getTopArtists(user, params) {\n        const response = await this.client.request('user.getTopArtists', {\n            ...params,\n            user\n        });\n        const artists = response.topartists.artist.map((a) => ({\n            name: a.name,\n            mbid: a.mbid,\n            url: a.url,\n            playCount: parseInt(a.playcount),\n            streamable: a.streamable === '1',\n            rank: parseInt(a['@attr'].rank),\n            images: parseLastfmImages(a.image)\n        }));\n        return {\n            artists,\n            pagination: parseLastfmPagination(response.topartists['@attr'])\n        };\n    }\n    async getTopTracks(user, params) {\n        const response = await this.client.request('user.getTopTracks', {\n            ...params,\n            user\n        });\n        const tracks = response.toptracks.track.map((t) => ({\n            name: t.name,\n            mbid: t.mbid,\n            url: t.url,\n            playCount: parseInt(t.playcount),\n            artist: t.artist,\n            streamable: t.streamable.fulltrack === '1',\n            rank: parseInt(t['@attr'].rank),\n            images: parseLastfmImages(t.image)\n        }));\n        return {\n            tracks,\n            pagination: parseLastfmPagination(response.toptracks['@attr'])\n        };\n    }\n}\n\nclass Track {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    async getInfo(trackName, artistName, params) {\n        const original = await this.client.request('track.getInfo', {\n            track: trackName,\n            artist: artistName,\n            mbid: params?.mbid,\n            autocorrect: params?.autoCorrect === true ? '1' : '0',\n            username: params?.username\n        });\n        if (!original.track)\n            return undefined;\n        return {\n            user: typeof original.track.userloved === 'string'\n                ? {\n                    loved: original.track.userloved === '1',\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    playCount: parseInt(original.track.userplaycount)\n                }\n                : undefined,\n            name: original.track.name,\n            mbid: original.track.mbid ?? undefined,\n            url: original.track.url,\n            duration: original.track.duration !== '0'\n                ? parseInt(original.track.duration)\n                : undefined,\n            listeners: parseInt(original.track.listeners),\n            playcount: parseInt(original.track.playcount),\n            artist: {\n                name: original.track.artist.name,\n                mbid: original.track.artist.mbid ?? undefined,\n                url: original.track.artist.url\n            },\n            album: original.track.album\n                ? {\n                    name: original.track.album.title,\n                    artist: original.track.album.artist,\n                    url: original.track.album.url,\n                    images: original.track.album.image\n                        ? parseLastfmImages(original.track.album.image)\n                        : undefined\n                }\n                : undefined,\n            tags: original.track.toptags?.tag,\n            wiki: original.track.wiki\n                ? {\n                    published: new Date(original.track.wiki.published),\n                    summary: original.track.wiki.summary,\n                    content: original.track.wiki.content\n                }\n                : undefined\n        };\n    }\n    async love(trackName, artistName, token) {\n        await this.client.request('track.love', {\n            track: trackName,\n            artist: artistName,\n            token\n        });\n    }\n    async unlove(trackName, artistName, token) {\n        await this.client.request('track.unlove', {\n            track: trackName,\n            artist: artistName,\n            token\n        });\n    }\n}\n\nconst parseAlbumInfoTracks = (tracks) => {\n    return tracks.map((track) => ({\n        name: track.name,\n        duration: track.duration,\n        artist: {\n            name: track.artist.name,\n            mbid: track.artist.mbid ?? undefined,\n            url: track.artist.url\n        },\n        url: track.url,\n        rank: track['@attr']?.rank ?? undefined\n    }));\n};\nclass Album {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    async getInfo(albumName, artistName, params) {\n        const original = await this.client.request('album.getInfo', {\n            album: albumName,\n            artist: artistName,\n            mbid: params?.mbid,\n            autocorrect: params?.autoCorrect === true ? '1' : '0',\n            username: params?.username,\n            lang: params?.biographyLanguage\n        });\n        if (!original.album)\n            return undefined;\n        return {\n            artist: original.album.artist,\n            images: original.album.image\n                ? parseLastfmImages(original.album.image)\n                : undefined,\n            listeners: parseInt(original.album.listeners),\n            mbid: original.album.mbid !== '' ? original.album.mbid : undefined,\n            name: original.album.name,\n            playCount: parseInt(original.album.playcount),\n            tags: original.album.tags?.tag,\n            tracks: original.album.tracks?.track\n                ? parseAlbumInfoTracks(original.album.tracks?.track)\n                : undefined,\n            url: original.album.url,\n            user: original.album.userplaycount\n                ? { playCount: original.album.userplaycount }\n                : undefined,\n            wiki: original.album.wiki\n                ? {\n                    published: new Date(original.album.wiki.published),\n                    summary: original.album.wiki.summary,\n                    content: original.album.wiki.content\n                }\n                : undefined\n        };\n    }\n}\n\nconst parseSimilarArtists = (similarArtists) => {\n    return similarArtists.map((similarArtist) => ({\n        name: similarArtist.name,\n        url: similarArtist.url,\n        images: similarArtist.image\n            ? parseLastfmImages(similarArtist.image)\n            : undefined\n    }));\n};\nclass Artist {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    async getInfo(artistName, params) {\n        const original = await this.client.request('artist.getInfo', {\n            artist: artistName,\n            mbid: params?.mbid,\n            autocorrect: params?.autoCorrect === true ? '1' : '0',\n            username: params?.username,\n            lang: params?.biographyLanguage\n        });\n        if (!original.artist)\n            return undefined;\n        return {\n            name: original.artist.name,\n            mbid: original.artist.mbid,\n            url: original.artist.url,\n            images: original.artist.image\n                ? parseLastfmImages(original.artist.image)\n                : undefined,\n            streamable: original.artist.streamable === '1',\n            onTour: original.artist.ontour === '1',\n            listeners: parseInt(original.artist.stats.listeners),\n            playCount: parseInt(original.artist.stats.playcount),\n            user: original.artist.stats.userplaycount\n                ? { playCount: parseInt(original.artist.stats.userplaycount) }\n                : undefined,\n            similarArtists: original.artist.similar?.artist\n                ? parseSimilarArtists(original.artist.similar.artist)\n                : undefined,\n            tags: original.artist.tags?.tag,\n            wiki: original.artist.bio\n                ? {\n                    published: new Date(original.artist.bio.published),\n                    summary: original.artist.bio.summary,\n                    content: original.artist.bio.content\n                }\n                : undefined\n        };\n    }\n}\n\nclass Auth {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    async getToken() {\n        const original = await this.client.request('auth.getToken', undefined, true);\n        return original.token;\n    }\n    async getSession(token) {\n        const original = await this.client.request('auth.getSession', { token }, true);\n        return {\n            username: original.session.name,\n            key: original.session.key,\n            subscriber: original.session.subscriber === '1'\n        };\n    }\n}\n\nclass Utilities {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Returns the URL to the Last.fm authentication page\n     */\n    buildDesktopAuthURL(token) {\n        return `https://www.last.fm/api/auth/?api_key=${this.client.apiKey}&token=${token}`;\n    }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nclass LastClient {\n    apiKey;\n    apiSecret;\n    apiUrl = 'https://ws.audioscrobbler.com/2.0';\n    user = new User(this);\n    track = new Track(this);\n    album = new Album(this);\n    artist = new Artist(this);\n    auth = new Auth(this);\n    utilities = new Utilities(this);\n    headers;\n    constructor(apiKey, apiSecret, userAgent) {\n        this.apiKey = apiKey;\n        this.apiSecret = apiSecret;\n        if (!apiKey)\n            throw new Error('apiKey is required and is missing');\n        this.headers = {\n            'User-Agent': userAgent ??\n                'Unknown app (@musicorum/lastfm; github.com/musicorum-app/lastfm)'\n        };\n    }\n    onRequestStarted(method, params, internalData\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n    onRequestFinished(method, params, internalData, response\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n    /**\n     * @todo implement signed requests\n     */\n    async request(method, params, signed = false, write = false) {\n        if (signed && !this.apiSecret)\n            throw new Error('apiSecret is required for signed requests');\n        params = {\n            ...params,\n            method,\n            api_key: this.apiKey,\n            format: 'json'\n        };\n        const cleanParams = Object.fromEntries(Object.entries(params).filter(([_, v]) => !!v));\n        const searchParams = new URLSearchParams(cleanParams);\n        if (signed) {\n            // order cleanParams alphabetically by key\n            const orderedParams = Object.fromEntries(Object.entries(cleanParams).sort(([a], [b]) => a.localeCompare(b)));\n            const signature = Object.entries(orderedParams)\n                .filter(([k]) => k !== 'format')\n                .map(([k, v]) => `${k}${v}`)\n                .join('') + this.apiSecret;\n            const hashedSignature = crypto__WEBPACK_IMPORTED_MODULE_0__.createHash('md5')\n                .update(signature)\n                .digest('hex');\n            searchParams.set('api_sig', hashedSignature);\n        }\n        const queryString = searchParams.toString();\n        const internalData = {};\n        this.onRequestStarted(method, cleanParams, internalData);\n        const response = write\n            ? await fetch(`${this.apiUrl}/?format=json`, {\n                method: 'POST',\n                headers: this.headers,\n                body: queryString\n            })\n            : await fetch(`${this.apiUrl}?${queryString}`, { headers: this.headers });\n        const data = await response.json();\n        this.onRequestFinished(method, cleanParams, internalData, data);\n        if (!response.ok)\n            throw new LastfmError(data);\n        return data;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbXVzaWNvcnVtK2xhc3RmbUAwLjMuMS9ub2RlX21vZHVsZXMvQG11c2ljb3J1bS9sYXN0Zm0vZGlzdC9MYXN0Q2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQXFELEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUIsU0FBUyxNQUFNO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUUsRUFBRSxFQUFFO0FBQzFDO0FBQ0Esb0NBQW9DLDhDQUNUO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNkJBQTZCLFlBQVksR0FBRyxZQUFZLEtBQUssdUJBQXVCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JhcGhhZWxzYWxhamEvLi9ub2RlX21vZHVsZXMvLnBucG0vQG11c2ljb3J1bStsYXN0Zm1AMC4zLjEvbm9kZV9tb2R1bGVzL0BtdXNpY29ydW0vbGFzdGZtL2Rpc3QvTGFzdENsaWVudC5qcz8xYjI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuY2xhc3MgTGFzdGZtRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgcmVzcG9uc2U7XG4gICAgZXJyb3I7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIocmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICAgIH1cbn1cbi8qKlxuICogU291cmNlczoge0BsaW5rIGh0dHBzOi8vbGFzdGZtLWRvY3MuZ2l0aHViLmlvL2FwaS1kb2NzL2NvZGVzL30gYW5kIHtAbGluayBodHRwczovL3d3dy5sYXN0LmZtL2FwaS9lcnJvcmNvZGVzfVxuICovXG52YXIgTGFzdGZtRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChMYXN0Zm1FcnJvckNvZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNlcnZpY2UgZG9lcyBub3QgZXhpc3RcbiAgICAgKi9cbiAgICBMYXN0Zm1FcnJvckNvZGVbTGFzdGZtRXJyb3JDb2RlW1wiU0VSVklDRV9VTkFWQUlMQUJMRVwiXSA9IDJdID0gXCJTRVJWSUNFX1VOQVZBSUxBQkxFXCI7XG4gICAgLyoqXG4gICAgICogIE5vIG1ldGhvZCB3aXRoIHRoYXQgbmFtZSBpbiB0aGlzIHBhY2thZ2VcbiAgICAgKi9cbiAgICBMYXN0Zm1FcnJvckNvZGVbTGFzdGZtRXJyb3JDb2RlW1wiSU5WQUxJRF9NRVRIT0RcIl0gPSAzXSA9IFwiSU5WQUxJRF9NRVRIT0RcIjtcbiAgICAvKipcbiAgICAgKiBZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbnMgdG8gYWNjZXNzIHRoZSBzZXJ2aWNlXG4gICAgICovXG4gICAgTGFzdGZtRXJyb3JDb2RlW0xhc3RmbUVycm9yQ29kZVtcIkFVVEhFTlRJQ0FUSU9OX0ZBSUxFRFwiXSA9IDRdID0gXCJBVVRIRU5USUNBVElPTl9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNlcnZpY2UgZG9lc24ndCBleGlzdCBpbiB0aGF0IGZvcm1hdFxuICAgICAqL1xuICAgIExhc3RmbUVycm9yQ29kZVtMYXN0Zm1FcnJvckNvZGVbXCJJTlZBTElEX1JFU1BPTlNFX0ZPUk1BVFwiXSA9IDVdID0gXCJJTlZBTElEX1JFU1BPTlNFX0ZPUk1BVFwiO1xuICAgIC8qKlxuICAgICAqIFlvdXIgcmVxdWVzdCBpcyBtaXNzaW5nIGEgcmVxdWlyZWQgcGFyYW1ldGVyXG4gICAgICovXG4gICAgTGFzdGZtRXJyb3JDb2RlW0xhc3RmbUVycm9yQ29kZVtcIklOVkFMSURfUEFSQU1FVEVSXCJdID0gNl0gPSBcIklOVkFMSURfUEFSQU1FVEVSXCI7XG4gICAgLyoqXG4gICAgICogSW52YWxpZCByZXNvdXJjZSBzcGVjaWZpZWRcbiAgICAgKi9cbiAgICBMYXN0Zm1FcnJvckNvZGVbTGFzdGZtRXJyb3JDb2RlW1wiSU5WQUxJRF9SRVNPVVJDRVwiXSA9IDddID0gXCJJTlZBTElEX1JFU09VUkNFXCI7XG4gICAgLyoqXG4gICAgICogTW9zdCBsaWtlbHkgdGhlIGJhY2tlbmQgc2VydmljZSBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4uXG4gICAgICovXG4gICAgTGFzdGZtRXJyb3JDb2RlW0xhc3RmbUVycm9yQ29kZVtcIk9QRVJBVElPTl9GQUlMRURcIl0gPSA4XSA9IFwiT1BFUkFUSU9OX0ZBSUxFRFwiO1xuICAgIC8qKlxuICAgICAqICBJbnZhbGlkIHNlc3Npb24ga2V5IC0gUGxlYXNlIHJlLWF1dGhlbnRpY2F0ZVxuICAgICAqL1xuICAgIExhc3RmbUVycm9yQ29kZVtMYXN0Zm1FcnJvckNvZGVbXCJJTlZBTElEX1NFUlNTSU9OX1RPS0VOXCJdID0gOV0gPSBcIklOVkFMSURfU0VSU1NJT05fVE9LRU5cIjtcbiAgICAvKipcbiAgICAgKiBZb3UgbXVzdCBiZSBncmFudGVkIHdpdGggYSB2YWxpZCBrZXkgYnkgbGFzdC5mbVxuICAgICAqL1xuICAgIExhc3RmbUVycm9yQ29kZVtMYXN0Zm1FcnJvckNvZGVbXCJJTlZBTElEX0FQSV9UT0tFTlwiXSA9IDEwXSA9IFwiSU5WQUxJRF9BUElfVE9LRU5cIjtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNlcnZpY2UgaXMgdGVtcG9yYXJ5IG9mZmxpbmUuIFRyeSBhZ2FpbiBsYXRlci5cbiAgICAgKi9cbiAgICBMYXN0Zm1FcnJvckNvZGVbTGFzdGZtRXJyb3JDb2RlW1wiU0VSVklDRV9PRkZMSU5FXCJdID0gMTFdID0gXCJTRVJWSUNFX09GRkxJTkVcIjtcbiAgICAvKipcbiAgICAgKiBJbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUgc3VwcGxpZWRcbiAgICAgKi9cbiAgICBMYXN0Zm1FcnJvckNvZGVbTGFzdGZtRXJyb3JDb2RlW1wiSU5WQUxJRF9TSUdOQVRVUkVcIl0gPSAxM10gPSBcIklOVkFMSURfU0lHTkFUVVJFXCI7XG4gICAgLyoqXG4gICAgICogVGhpcyB0b2tlbiBoYXMgbm90IGJlZW4gYXV0aG9yaXplZFxuICAgICAqL1xuICAgIExhc3RmbUVycm9yQ29kZVtMYXN0Zm1FcnJvckNvZGVbXCJVTkFVVEhPUklaRURfVE9LRU5cIl0gPSAxNF0gPSBcIlVOQVVUSE9SSVpFRF9UT0tFTlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2aWNlIGlzIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlLCBwbGVhc2UgdHJ5IGFnYWluLlxuICAgICAqL1xuICAgIExhc3RmbUVycm9yQ29kZVtMYXN0Zm1FcnJvckNvZGVbXCJURU1QT1JBUllfRVJST1JcIl0gPSAxNl0gPSBcIlRFTVBPUkFSWV9FUlJPUlwiO1xuICAgIC8qKlxuICAgICAqIFVzZXIgcmVxdWlyZXMgdG8gYmUgbG9nZ2VkIGluIHRvIHVzZSB0aGlzIG1ldGhvZFxuICAgICAqIFRoaXMgbWF5IGJlIGNhdXNlZCB3aGVuIHRyeWluZyB0byBnZXQgc29tZSB1c2VyJ3MgZGF0YSB3aXRoIHJlc3RyaWN0ZWQgcHJpdmljeVxuICAgICAqL1xuICAgIExhc3RmbUVycm9yQ29kZVtMYXN0Zm1FcnJvckNvZGVbXCJSRVFVSVJFU19MT0dJTlwiXSA9IDE3XSA9IFwiUkVRVUlSRVNfTE9HSU5cIjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGFwcGxpY2F0aW9uIGlzIG5vdCBhbGxvd2VkIHRvIG1ha2UgcmVxdWVzdHMgdG8gdGhlIHdlYiBzZXJ2aWNlc1xuICAgICAqL1xuICAgIExhc3RmbUVycm9yQ29kZVtMYXN0Zm1FcnJvckNvZGVbXCJBUElfS0VZX1NVU1BFTkRFRFwiXSA9IDI2XSA9IFwiQVBJX0tFWV9TVVNQRU5ERURcIjtcbiAgICAvKipcbiAgICAgKiBUaGlzIHR5cGUgb2YgcmVxdWVzdCBpcyBubyBsb25nZXIgc3VwcG9ydGVkXG4gICAgICovXG4gICAgTGFzdGZtRXJyb3JDb2RlW0xhc3RmbUVycm9yQ29kZVtcIkRFUFJFQ0FURURcIl0gPSAyN10gPSBcIkRFUFJFQ0FURURcIjtcbiAgICAvKipcbiAgICAgKiBZb3VyIElQIGhhcyBtYWRlIHRvbyBtYW55IHJlcXVlc3RzIGluIGEgc2hvcnQgcGVyaW9kXG4gICAgICovXG4gICAgTGFzdGZtRXJyb3JDb2RlW0xhc3RmbUVycm9yQ29kZVtcIlJBVEVfTElNSVRfRVhDRUVERURcIl0gPSAyOV0gPSBcIlJBVEVfTElNSVRfRVhDRUVERURcIjtcbn0pKExhc3RmbUVycm9yQ29kZSB8fCAoTGFzdGZtRXJyb3JDb2RlID0ge30pKTtcblxuLyoqXG4gKiBQYWdpbmF0ZWQgcmVzdWx0cyBmb3IgYSByZXNvdXJjZS4gVGhpcyBjYW4gYmUgdXNlZCB0byBnZXQgc3BlY2lmaWMgcGFnZXMgb3IgbXVsdGlwbGUgcGFnZXNcbiAqL1xuY2xhc3MgUGFnaW5hdGVkUmVzdWx0IHtcbiAgICByZXF1ZXN0ZXI7XG4gICAgdG90YWxQYWdlcztcbiAgICB0b3RhbFJlc3VsdHM7XG4gICAgcGVyUGFnZTtcbiAgICBwYWdlcyA9IFtdO1xuICAgIGNvbnN0cnVjdG9yKGF0dHIsIHJlcXVlc3Rlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3RlciA9IHJlcXVlc3RlcjtcbiAgICAgICAgdGhpcy50b3RhbFBhZ2VzID0gcGFyc2VJbnQoYXR0ci50b3RhbFBhZ2VzKTtcbiAgICAgICAgdGhpcy5wZXJQYWdlID0gcGFyc2VJbnQoYXR0ci5wZXJQYWdlKTtcbiAgICAgICAgdGhpcy50b3RhbFJlc3VsdHMgPSBwYXJzZUludChhdHRyLnRvdGFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBjb250ZW50cyBvZiBhIHBhZ2UgdG8gdGhpcyBwYWdpbmF0ZWQgcmVzdWx0XG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHBhZ2UgbnVtYmVyIG9mIHRoZSBjb250ZW50cyB0byBhcHBlbmRcbiAgICAgKiBAcGFyYW0gaXRlbXMgVGhlIHJlc291cmNlcyBvZiB0aGF0IHBhZ2UgdG8gYXBwZW5kXG4gICAgICogQHJldHVybnMgVGhpcyBjdXJyZW50IHBhZ2luYXRlZCByZXN1bHRcbiAgICAgKi9cbiAgICBhcHBlbmRQYWdlKHBhZ2UsIGl0ZW1zKSB7XG4gICAgICAgIC8vIHBhZ2UgaW5kZXggaXMgY29udmVydGVkIHRvIGFycmF5IGluZGV4IHN1YnRyYWN0aW5nIG9uZSBudW1iZXJcbiAgICAgICAgLy8gZS5nLiBwYWdlIDEgcmVmZmVycyB0byBpbmRleCAwXG4gICAgICAgIHRoaXMucGFnZXNbLS1wYWdlXSA9IGl0ZW1zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb250ZW50cyBmcm9tIGEgcGFnZVxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSBwYWdlIHRvIGdldCB0aGUgY29udGVudHMgZnJvbS4gUGFnZSBudW1iZXJzIHN0YXJ0IGZyb20gMVxuICAgICAqIEByZXR1cm5zIEEgbGlzdCBvZiB0aGUgcmVzb3VyY2VzIG9mIHRoYXQgc3BlY2lmaWMgcGFnZVxuICAgICAqL1xuICAgIGdldFBhZ2UocGFnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlc1stLXBhZ2VdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGNvbnRlbnRzIGZldGNoZWQgZnJvbSB0aGlzIHBhZ2luYXRlZCByZXN1bHRcbiAgICAgKiBAcmV0dXJucyBBbGwgY29udGVudHMgb2YgYWxsIGZldGNoZWQgcGFnZXMuIE5vdGUgdGhhdCBtaXNzaW5nIHBhZ2VzIHdpbGwgYmUgaWdub2VkXG4gICAgICovXG4gICAgZ2V0QWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlcy5mbGF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgY29udGVudCBmcm9tIGEgcGFnZSBmcm9tIHRoZSBBUEksIGlmIGl0IHdhc24ndCBmZXRjaGVkIHlldFxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSBwYWdlIG51bWJlciB0byBmZXRjaCBjb250ZW50IGZyb20uIFBhZ2UgbnVtYmVycyBzdGFydCBmcm9tIDFcbiAgICAgKiBAcGFyYW0gZm9yY2UgVGhpcyB3aWxsIGZvcmNlIHRvIGZldGNoIHRoYXQgcGFnZSwgZXZlbiBpZiBpdCdzIGFscmVhZHkgZmV0Y2hlZFxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHRzIGZyb20gdGhhdCBwYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoUGFnZShwYWdlLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnBhZ2VzW3BhZ2UgLSAxXSAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhZ2UocGFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMucmVxdWVzdGVyKHBhZ2UpO1xuICAgICAgICB0aGlzLmFwcGVuZFBhZ2UocGFnZSwgcmVzdWx0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMYXN0Zm1JbWFnZXMoaW1hZ2VzKSB7XG4gICAgcmV0dXJuIGltYWdlc1xuICAgICAgICAuZmlsdGVyKChpKSA9PiAhIWlbJyN0ZXh0J10pXG4gICAgICAgIC5tYXAoKGkpID0+ICh7XG4gICAgICAgIHNpemU6IGkuc2l6ZSxcbiAgICAgICAgdXJsOiBpWycjdGV4dCddXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcGFyc2VMYXN0Zm1QYWdpbmF0aW9uKG9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZTogcGFyc2VJbnQob3JpZ2luYWwucGFnZSksXG4gICAgICAgIHRvdGFsUGFnZXM6IHBhcnNlSW50KG9yaWdpbmFsLnRvdGFsUGFnZXMpLFxuICAgICAgICBwZXJQYWdlOiBwYXJzZUludChvcmlnaW5hbC5wZXJQYWdlKSxcbiAgICAgICAgdG90YWw6IHBhcnNlSW50KG9yaWdpbmFsLnRvdGFsKVxuICAgIH07XG59XG5cbmNsYXNzIFVzZXIge1xuICAgIGNsaWVudDtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGFzeW5jIGdldEluZm8odXNlcikge1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QoJ3VzZXIuZ2V0SW5mbycsIHsgdXNlciB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLnVzZXIubmFtZSxcbiAgICAgICAgICAgIHJlYWxOYW1lOiBvcmlnaW5hbC51c2VyLm5hbWUsXG4gICAgICAgICAgICBhZ2U6IHBhcnNlSW50KG9yaWdpbmFsLnVzZXIuYWdlKSxcbiAgICAgICAgICAgIHBsYXlDb3VudDogcGFyc2VJbnQob3JpZ2luYWwudXNlci5wbGF5Y291bnQpLFxuICAgICAgICAgICAgY291bnRyeTogb3JpZ2luYWwudXNlci5jb3VudHJ5LFxuICAgICAgICAgICAgcmVnaXN0ZXJlZDogbmV3IERhdGUocGFyc2VJbnQob3JpZ2luYWwudXNlci5yZWdpc3RlcmVkLnVuaXh0aW1lKSAqIDEwMDApLFxuICAgICAgICAgICAgZ2VuZGVyOiBvcmlnaW5hbC51c2VyLmdlbmRlcixcbiAgICAgICAgICAgIHN1YnNjcmliZXI6IG9yaWdpbmFsLnVzZXIuc3Vic2NyaWJlciA9PT0gJzEnLFxuICAgICAgICAgICAgaW1hZ2VzOiBwYXJzZUxhc3RmbUltYWdlcyhvcmlnaW5hbC51c2VyLmltYWdlKSxcbiAgICAgICAgICAgIHVybDogb3JpZ2luYWwudXNlci51cmxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVjZW50VHJhY2tzKHVzZXIsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBzdHJpbmdQYXJhbXMgPSB7XG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgbGltaXQ6IChwYXJhbXM/LmxpbWl0ID8/IDUwKS50b1N0cmluZygpLFxuICAgICAgICAgICAgcGFnZTogKHBhcmFtcz8ucGFnZSA/PyAxKS50b1N0cmluZygpLFxuICAgICAgICAgICAgZXh0ZW5kZWQ6IHBhcmFtcz8uZXh0ZW5kZWQgPT09IHRydWUgPyAnMScgOiAnMCdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhcmFtcz8uZnJvbSkge1xuICAgICAgICAgICAgc3RyaW5nUGFyYW1zLmZyb20gPSBNYXRoLnJvdW5kKHBhcmFtcy5mcm9tLmdldFRpbWUoKSAvIDEwMDApLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcz8udG8pIHtcbiAgICAgICAgICAgIHN0cmluZ1BhcmFtcy50byA9IE1hdGgucm91bmQocGFyYW1zLnRvLmdldFRpbWUoKSAvIDEwMDApLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KCd1c2VyLmdldFJlY2VudFRyYWNrcycsIHN0cmluZ1BhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRyYWNrTGlzdCA9IEFycmF5LmlzQXJyYXkocmVzcG9uc2UucmVjZW50dHJhY2tzLnRyYWNrKVxuICAgICAgICAgICAgPyByZXNwb25zZS5yZWNlbnR0cmFja3MudHJhY2tcbiAgICAgICAgICAgIDogW3Jlc3BvbnNlLnJlY2VudHRyYWNrcy50cmFja107XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHRyYWNrTGlzdC5tYXAoKHRyYWNrKSA9PiAoe1xuICAgICAgICAgICAgbmFtZTogdHJhY2submFtZSxcbiAgICAgICAgICAgIG1iaWQ6IHRyYWNrLm1iaWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3RyZWFtYWJsZTogdHJhY2suc3RyZWFtYWJsZSA9PSAnMScsXG4gICAgICAgICAgICBhcnRpc3Q6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0cmFjay5hcnRpc3QubmFtZSB8fCB0cmFjay5hcnRpc3RbJyN0ZXh0J10sXG4gICAgICAgICAgICAgICAgbWJpZDogdHJhY2suYXJ0aXN0Lm1iaWQgPz8gdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1hZ2VzOiBwYXJzZUxhc3RmbUltYWdlcyh0cmFjay5pbWFnZSksXG4gICAgICAgICAgICBhbGJ1bToge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRyYWNrLmFsYnVtWycjdGV4dCddLFxuICAgICAgICAgICAgICAgIG1iaWQ6IHRyYWNrLmFsYnVtLm1iaWQgPz8gdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXJsOiB0cmFjay51cmwsXG4gICAgICAgICAgICBkYXRlOiB0cmFjay5kYXRlPy51dHNcbiAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKHBhcnNlSW50KHRyYWNrLmRhdGUudXRzKSAqIDEwMDApXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBub3dQbGF5aW5nOiB0cmFja1snQGF0dHInXT8ubm93cGxheWluZyA9PT0gJ3RydWUnLFxuICAgICAgICAgICAgbG92ZWQ6ICdsb3ZlZCcgaW4gdHJhY2sgPyB0cmFjay5sb3ZlZCA9PT0gJzEnIDogdW5kZWZpbmVkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNrcyxcbiAgICAgICAgICAgIGF0dHI6IHJlc3BvbnNlLnJlY2VudHRyYWNrc1snQGF0dHInXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlbnRUcmFja3NQYWdpbmF0ZWQodXNlciwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFJlY2VudFRyYWNrcyh1c2VyLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBwYWdpbmF0ZWQgPSBuZXcgUGFnaW5hdGVkUmVzdWx0KG1ldGFkYXRhUmVzcG9uc2UuYXR0ciwgYXN5bmMgKHBhZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IGF3YWl0IHRoaXMuZ2V0UmVjZW50VHJhY2tzKHVzZXIsIHtcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAgcGFnZVxuICAgICAgICAgICAgfSkudGhlbigocikgPT4gci50cmFja3MpO1xuICAgICAgICAgICAgLy8gc2tpcCBmaXJzdCBpdGVtIGlmIGl0cyBub3cgcGxheWluZyBhbmQgbm90IGF0IGZpcnN0IHBhZ2UsIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICAgICAgcmV0dXJuIHBhZ2UgIT09IDEgJiYgdHJhY2tzWzBdLm5vd1BsYXlpbmcgPyB0cmFja3Muc2xpY2UoMSkgOiB0cmFja3M7XG4gICAgICAgIH0pO1xuICAgICAgICBwYWdpbmF0ZWQuYXBwZW5kUGFnZShwYXJhbXM/LnBhZ2UgPz8gMSwgbWV0YWRhdGFSZXNwb25zZS50cmFja3MpO1xuICAgICAgICByZXR1cm4gcGFnaW5hdGVkO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb3BBbGJ1bXModXNlciwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCgndXNlci5nZXRUb3BBbGJ1bXMnLCB7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICB1c2VyXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbGJ1bXMgPSByZXNwb25zZS50b3BhbGJ1bXMuYWxidW0ubWFwKChhKSA9PiAoe1xuICAgICAgICAgICAgbmFtZTogYS5uYW1lLFxuICAgICAgICAgICAgYXJ0aXN0OiBhLmFydGlzdCxcbiAgICAgICAgICAgIHBsYXlDb3VudDogcGFyc2VJbnQoYS5wbGF5Y291bnQpLFxuICAgICAgICAgICAgcmFuazogcGFyc2VJbnQoYVsnQGF0dHInXS5yYW5rKSxcbiAgICAgICAgICAgIG1iaWQ6IGEubWJpZCxcbiAgICAgICAgICAgIGltYWdlczogcGFyc2VMYXN0Zm1JbWFnZXMoYS5pbWFnZSlcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxidW1zLFxuICAgICAgICAgICAgcGFnaW5hdGlvbjogcGFyc2VMYXN0Zm1QYWdpbmF0aW9uKHJlc3BvbnNlLnRvcGFsYnVtc1snQGF0dHInXSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9wQXJ0aXN0cyh1c2VyLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KCd1c2VyLmdldFRvcEFydGlzdHMnLCB7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICB1c2VyXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhcnRpc3RzID0gcmVzcG9uc2UudG9wYXJ0aXN0cy5hcnRpc3QubWFwKChhKSA9PiAoe1xuICAgICAgICAgICAgbmFtZTogYS5uYW1lLFxuICAgICAgICAgICAgbWJpZDogYS5tYmlkLFxuICAgICAgICAgICAgdXJsOiBhLnVybCxcbiAgICAgICAgICAgIHBsYXlDb3VudDogcGFyc2VJbnQoYS5wbGF5Y291bnQpLFxuICAgICAgICAgICAgc3RyZWFtYWJsZTogYS5zdHJlYW1hYmxlID09PSAnMScsXG4gICAgICAgICAgICByYW5rOiBwYXJzZUludChhWydAYXR0ciddLnJhbmspLFxuICAgICAgICAgICAgaW1hZ2VzOiBwYXJzZUxhc3RmbUltYWdlcyhhLmltYWdlKVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcnRpc3RzLFxuICAgICAgICAgICAgcGFnaW5hdGlvbjogcGFyc2VMYXN0Zm1QYWdpbmF0aW9uKHJlc3BvbnNlLnRvcGFydGlzdHNbJ0BhdHRyJ10pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldFRvcFRyYWNrcyh1c2VyLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KCd1c2VyLmdldFRvcFRyYWNrcycsIHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIHVzZXJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHJlc3BvbnNlLnRvcHRyYWNrcy50cmFjay5tYXAoKHQpID0+ICh7XG4gICAgICAgICAgICBuYW1lOiB0Lm5hbWUsXG4gICAgICAgICAgICBtYmlkOiB0Lm1iaWQsXG4gICAgICAgICAgICB1cmw6IHQudXJsLFxuICAgICAgICAgICAgcGxheUNvdW50OiBwYXJzZUludCh0LnBsYXljb3VudCksXG4gICAgICAgICAgICBhcnRpc3Q6IHQuYXJ0aXN0LFxuICAgICAgICAgICAgc3RyZWFtYWJsZTogdC5zdHJlYW1hYmxlLmZ1bGx0cmFjayA9PT0gJzEnLFxuICAgICAgICAgICAgcmFuazogcGFyc2VJbnQodFsnQGF0dHInXS5yYW5rKSxcbiAgICAgICAgICAgIGltYWdlczogcGFyc2VMYXN0Zm1JbWFnZXModC5pbWFnZSlcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHJhY2tzLFxuICAgICAgICAgICAgcGFnaW5hdGlvbjogcGFyc2VMYXN0Zm1QYWdpbmF0aW9uKHJlc3BvbnNlLnRvcHRyYWNrc1snQGF0dHInXSlcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIFRyYWNrIHtcbiAgICBjbGllbnQ7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBhc3luYyBnZXRJbmZvKHRyYWNrTmFtZSwgYXJ0aXN0TmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCgndHJhY2suZ2V0SW5mbycsIHtcbiAgICAgICAgICAgIHRyYWNrOiB0cmFja05hbWUsXG4gICAgICAgICAgICBhcnRpc3Q6IGFydGlzdE5hbWUsXG4gICAgICAgICAgICBtYmlkOiBwYXJhbXM/Lm1iaWQsXG4gICAgICAgICAgICBhdXRvY29ycmVjdDogcGFyYW1zPy5hdXRvQ29ycmVjdCA9PT0gdHJ1ZSA/ICcxJyA6ICcwJyxcbiAgICAgICAgICAgIHVzZXJuYW1lOiBwYXJhbXM/LnVzZXJuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW9yaWdpbmFsLnRyYWNrKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXI6IHR5cGVvZiBvcmlnaW5hbC50cmFjay51c2VybG92ZWQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGxvdmVkOiBvcmlnaW5hbC50cmFjay51c2VybG92ZWQgPT09ICcxJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgcGxheUNvdW50OiBwYXJzZUludChvcmlnaW5hbC50cmFjay51c2VycGxheWNvdW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLnRyYWNrLm5hbWUsXG4gICAgICAgICAgICBtYmlkOiBvcmlnaW5hbC50cmFjay5tYmlkID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVybDogb3JpZ2luYWwudHJhY2sudXJsLFxuICAgICAgICAgICAgZHVyYXRpb246IG9yaWdpbmFsLnRyYWNrLmR1cmF0aW9uICE9PSAnMCdcbiAgICAgICAgICAgICAgICA/IHBhcnNlSW50KG9yaWdpbmFsLnRyYWNrLmR1cmF0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGlzdGVuZXJzOiBwYXJzZUludChvcmlnaW5hbC50cmFjay5saXN0ZW5lcnMpLFxuICAgICAgICAgICAgcGxheWNvdW50OiBwYXJzZUludChvcmlnaW5hbC50cmFjay5wbGF5Y291bnQpLFxuICAgICAgICAgICAgYXJ0aXN0OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwudHJhY2suYXJ0aXN0Lm5hbWUsXG4gICAgICAgICAgICAgICAgbWJpZDogb3JpZ2luYWwudHJhY2suYXJ0aXN0Lm1iaWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHVybDogb3JpZ2luYWwudHJhY2suYXJ0aXN0LnVybFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFsYnVtOiBvcmlnaW5hbC50cmFjay5hbGJ1bVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC50cmFjay5hbGJ1bS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgYXJ0aXN0OiBvcmlnaW5hbC50cmFjay5hbGJ1bS5hcnRpc3QsXG4gICAgICAgICAgICAgICAgICAgIHVybDogb3JpZ2luYWwudHJhY2suYWxidW0udXJsLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZXM6IG9yaWdpbmFsLnRyYWNrLmFsYnVtLmltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHBhcnNlTGFzdGZtSW1hZ2VzKG9yaWdpbmFsLnRyYWNrLmFsYnVtLmltYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0YWdzOiBvcmlnaW5hbC50cmFjay50b3B0YWdzPy50YWcsXG4gICAgICAgICAgICB3aWtpOiBvcmlnaW5hbC50cmFjay53aWtpXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlZDogbmV3IERhdGUob3JpZ2luYWwudHJhY2sud2lraS5wdWJsaXNoZWQpLFxuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBvcmlnaW5hbC50cmFjay53aWtpLnN1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9yaWdpbmFsLnRyYWNrLndpa2kuY29udGVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBsb3ZlKHRyYWNrTmFtZSwgYXJ0aXN0TmFtZSwgdG9rZW4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCgndHJhY2subG92ZScsIHtcbiAgICAgICAgICAgIHRyYWNrOiB0cmFja05hbWUsXG4gICAgICAgICAgICBhcnRpc3Q6IGFydGlzdE5hbWUsXG4gICAgICAgICAgICB0b2tlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdW5sb3ZlKHRyYWNrTmFtZSwgYXJ0aXN0TmFtZSwgdG9rZW4pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCgndHJhY2sudW5sb3ZlJywge1xuICAgICAgICAgICAgdHJhY2s6IHRyYWNrTmFtZSxcbiAgICAgICAgICAgIGFydGlzdDogYXJ0aXN0TmFtZSxcbiAgICAgICAgICAgIHRva2VuXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgcGFyc2VBbGJ1bUluZm9UcmFja3MgPSAodHJhY2tzKSA9PiB7XG4gICAgcmV0dXJuIHRyYWNrcy5tYXAoKHRyYWNrKSA9PiAoe1xuICAgICAgICBuYW1lOiB0cmFjay5uYW1lLFxuICAgICAgICBkdXJhdGlvbjogdHJhY2suZHVyYXRpb24sXG4gICAgICAgIGFydGlzdDoge1xuICAgICAgICAgICAgbmFtZTogdHJhY2suYXJ0aXN0Lm5hbWUsXG4gICAgICAgICAgICBtYmlkOiB0cmFjay5hcnRpc3QubWJpZCA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICB1cmw6IHRyYWNrLmFydGlzdC51cmxcbiAgICAgICAgfSxcbiAgICAgICAgdXJsOiB0cmFjay51cmwsXG4gICAgICAgIHJhbms6IHRyYWNrWydAYXR0ciddPy5yYW5rID8/IHVuZGVmaW5lZFxuICAgIH0pKTtcbn07XG5jbGFzcyBBbGJ1bSB7XG4gICAgY2xpZW50O1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SW5mbyhhbGJ1bU5hbWUsIGFydGlzdE5hbWUsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3QoJ2FsYnVtLmdldEluZm8nLCB7XG4gICAgICAgICAgICBhbGJ1bTogYWxidW1OYW1lLFxuICAgICAgICAgICAgYXJ0aXN0OiBhcnRpc3ROYW1lLFxuICAgICAgICAgICAgbWJpZDogcGFyYW1zPy5tYmlkLFxuICAgICAgICAgICAgYXV0b2NvcnJlY3Q6IHBhcmFtcz8uYXV0b0NvcnJlY3QgPT09IHRydWUgPyAnMScgOiAnMCcsXG4gICAgICAgICAgICB1c2VybmFtZTogcGFyYW1zPy51c2VybmFtZSxcbiAgICAgICAgICAgIGxhbmc6IHBhcmFtcz8uYmlvZ3JhcGh5TGFuZ3VhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghb3JpZ2luYWwuYWxidW0pXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXJ0aXN0OiBvcmlnaW5hbC5hbGJ1bS5hcnRpc3QsXG4gICAgICAgICAgICBpbWFnZXM6IG9yaWdpbmFsLmFsYnVtLmltYWdlXG4gICAgICAgICAgICAgICAgPyBwYXJzZUxhc3RmbUltYWdlcyhvcmlnaW5hbC5hbGJ1bS5pbWFnZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxpc3RlbmVyczogcGFyc2VJbnQob3JpZ2luYWwuYWxidW0ubGlzdGVuZXJzKSxcbiAgICAgICAgICAgIG1iaWQ6IG9yaWdpbmFsLmFsYnVtLm1iaWQgIT09ICcnID8gb3JpZ2luYWwuYWxidW0ubWJpZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLmFsYnVtLm5hbWUsXG4gICAgICAgICAgICBwbGF5Q291bnQ6IHBhcnNlSW50KG9yaWdpbmFsLmFsYnVtLnBsYXljb3VudCksXG4gICAgICAgICAgICB0YWdzOiBvcmlnaW5hbC5hbGJ1bS50YWdzPy50YWcsXG4gICAgICAgICAgICB0cmFja3M6IG9yaWdpbmFsLmFsYnVtLnRyYWNrcz8udHJhY2tcbiAgICAgICAgICAgICAgICA/IHBhcnNlQWxidW1JbmZvVHJhY2tzKG9yaWdpbmFsLmFsYnVtLnRyYWNrcz8udHJhY2spXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1cmw6IG9yaWdpbmFsLmFsYnVtLnVybCxcbiAgICAgICAgICAgIHVzZXI6IG9yaWdpbmFsLmFsYnVtLnVzZXJwbGF5Y291bnRcbiAgICAgICAgICAgICAgICA/IHsgcGxheUNvdW50OiBvcmlnaW5hbC5hbGJ1bS51c2VycGxheWNvdW50IH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHdpa2k6IG9yaWdpbmFsLmFsYnVtLndpa2lcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVkOiBuZXcgRGF0ZShvcmlnaW5hbC5hbGJ1bS53aWtpLnB1Ymxpc2hlZCksXG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IG9yaWdpbmFsLmFsYnVtLndpa2kuc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb3JpZ2luYWwuYWxidW0ud2lraS5jb250ZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jb25zdCBwYXJzZVNpbWlsYXJBcnRpc3RzID0gKHNpbWlsYXJBcnRpc3RzKSA9PiB7XG4gICAgcmV0dXJuIHNpbWlsYXJBcnRpc3RzLm1hcCgoc2ltaWxhckFydGlzdCkgPT4gKHtcbiAgICAgICAgbmFtZTogc2ltaWxhckFydGlzdC5uYW1lLFxuICAgICAgICB1cmw6IHNpbWlsYXJBcnRpc3QudXJsLFxuICAgICAgICBpbWFnZXM6IHNpbWlsYXJBcnRpc3QuaW1hZ2VcbiAgICAgICAgICAgID8gcGFyc2VMYXN0Zm1JbWFnZXMoc2ltaWxhckFydGlzdC5pbWFnZSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgfSkpO1xufTtcbmNsYXNzIEFydGlzdCB7XG4gICAgY2xpZW50O1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SW5mbyhhcnRpc3ROYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhcnRpc3QuZ2V0SW5mbycsIHtcbiAgICAgICAgICAgIGFydGlzdDogYXJ0aXN0TmFtZSxcbiAgICAgICAgICAgIG1iaWQ6IHBhcmFtcz8ubWJpZCxcbiAgICAgICAgICAgIGF1dG9jb3JyZWN0OiBwYXJhbXM/LmF1dG9Db3JyZWN0ID09PSB0cnVlID8gJzEnIDogJzAnLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHBhcmFtcz8udXNlcm5hbWUsXG4gICAgICAgICAgICBsYW5nOiBwYXJhbXM/LmJpb2dyYXBoeUxhbmd1YWdlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW9yaWdpbmFsLmFydGlzdClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5hcnRpc3QubmFtZSxcbiAgICAgICAgICAgIG1iaWQ6IG9yaWdpbmFsLmFydGlzdC5tYmlkLFxuICAgICAgICAgICAgdXJsOiBvcmlnaW5hbC5hcnRpc3QudXJsLFxuICAgICAgICAgICAgaW1hZ2VzOiBvcmlnaW5hbC5hcnRpc3QuaW1hZ2VcbiAgICAgICAgICAgICAgICA/IHBhcnNlTGFzdGZtSW1hZ2VzKG9yaWdpbmFsLmFydGlzdC5pbWFnZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0cmVhbWFibGU6IG9yaWdpbmFsLmFydGlzdC5zdHJlYW1hYmxlID09PSAnMScsXG4gICAgICAgICAgICBvblRvdXI6IG9yaWdpbmFsLmFydGlzdC5vbnRvdXIgPT09ICcxJyxcbiAgICAgICAgICAgIGxpc3RlbmVyczogcGFyc2VJbnQob3JpZ2luYWwuYXJ0aXN0LnN0YXRzLmxpc3RlbmVycyksXG4gICAgICAgICAgICBwbGF5Q291bnQ6IHBhcnNlSW50KG9yaWdpbmFsLmFydGlzdC5zdGF0cy5wbGF5Y291bnQpLFxuICAgICAgICAgICAgdXNlcjogb3JpZ2luYWwuYXJ0aXN0LnN0YXRzLnVzZXJwbGF5Y291bnRcbiAgICAgICAgICAgICAgICA/IHsgcGxheUNvdW50OiBwYXJzZUludChvcmlnaW5hbC5hcnRpc3Quc3RhdHMudXNlcnBsYXljb3VudCkgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2ltaWxhckFydGlzdHM6IG9yaWdpbmFsLmFydGlzdC5zaW1pbGFyPy5hcnRpc3RcbiAgICAgICAgICAgICAgICA/IHBhcnNlU2ltaWxhckFydGlzdHMob3JpZ2luYWwuYXJ0aXN0LnNpbWlsYXIuYXJ0aXN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGFnczogb3JpZ2luYWwuYXJ0aXN0LnRhZ3M/LnRhZyxcbiAgICAgICAgICAgIHdpa2k6IG9yaWdpbmFsLmFydGlzdC5iaW9cbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVkOiBuZXcgRGF0ZShvcmlnaW5hbC5hcnRpc3QuYmlvLnB1Ymxpc2hlZCksXG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IG9yaWdpbmFsLmFydGlzdC5iaW8uc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogb3JpZ2luYWwuYXJ0aXN0LmJpby5jb250ZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jbGFzcyBBdXRoIHtcbiAgICBjbGllbnQ7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbigpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KCdhdXRoLmdldFRva2VuJywgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLnRva2VuO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZXNzaW9uKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCgnYXV0aC5nZXRTZXNzaW9uJywgeyB0b2tlbiB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiBvcmlnaW5hbC5zZXNzaW9uLm5hbWUsXG4gICAgICAgICAgICBrZXk6IG9yaWdpbmFsLnNlc3Npb24ua2V5LFxuICAgICAgICAgICAgc3Vic2NyaWJlcjogb3JpZ2luYWwuc2Vzc2lvbi5zdWJzY3JpYmVyID09PSAnMSdcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIFV0aWxpdGllcyB7XG4gICAgY2xpZW50O1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVJMIHRvIHRoZSBMYXN0LmZtIGF1dGhlbnRpY2F0aW9uIHBhZ2VcbiAgICAgKi9cbiAgICBidWlsZERlc2t0b3BBdXRoVVJMKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly93d3cubGFzdC5mbS9hcGkvYXV0aC8/YXBpX2tleT0ke3RoaXMuY2xpZW50LmFwaUtleX0mdG9rZW49JHt0b2tlbn1gO1xuICAgIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5jbGFzcyBMYXN0Q2xpZW50IHtcbiAgICBhcGlLZXk7XG4gICAgYXBpU2VjcmV0O1xuICAgIGFwaVVybCA9ICdodHRwczovL3dzLmF1ZGlvc2Nyb2JibGVyLmNvbS8yLjAnO1xuICAgIHVzZXIgPSBuZXcgVXNlcih0aGlzKTtcbiAgICB0cmFjayA9IG5ldyBUcmFjayh0aGlzKTtcbiAgICBhbGJ1bSA9IG5ldyBBbGJ1bSh0aGlzKTtcbiAgICBhcnRpc3QgPSBuZXcgQXJ0aXN0KHRoaXMpO1xuICAgIGF1dGggPSBuZXcgQXV0aCh0aGlzKTtcbiAgICB1dGlsaXRpZXMgPSBuZXcgVXRpbGl0aWVzKHRoaXMpO1xuICAgIGhlYWRlcnM7XG4gICAgY29uc3RydWN0b3IoYXBpS2V5LCBhcGlTZWNyZXQsIHVzZXJBZ2VudCkge1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICAgICAgdGhpcy5hcGlTZWNyZXQgPSBhcGlTZWNyZXQ7XG4gICAgICAgIGlmICghYXBpS2V5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcGlLZXkgaXMgcmVxdWlyZWQgYW5kIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiB1c2VyQWdlbnQgPz9cbiAgICAgICAgICAgICAgICAnVW5rbm93biBhcHAgKEBtdXNpY29ydW0vbGFzdGZtOyBnaXRodWIuY29tL211c2ljb3J1bS1hcHAvbGFzdGZtKSdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb25SZXF1ZXN0U3RhcnRlZChtZXRob2QsIHBhcmFtcywgaW50ZXJuYWxEYXRhXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgICkgeyB9XG4gICAgb25SZXF1ZXN0RmluaXNoZWQobWV0aG9kLCBwYXJhbXMsIGludGVybmFsRGF0YSwgcmVzcG9uc2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgKSB7IH1cbiAgICAvKipcbiAgICAgKiBAdG9kbyBpbXBsZW1lbnQgc2lnbmVkIHJlcXVlc3RzXG4gICAgICovXG4gICAgYXN5bmMgcmVxdWVzdChtZXRob2QsIHBhcmFtcywgc2lnbmVkID0gZmFsc2UsIHdyaXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHNpZ25lZCAmJiAhdGhpcy5hcGlTZWNyZXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FwaVNlY3JldCBpcyByZXF1aXJlZCBmb3Igc2lnbmVkIHJlcXVlc3RzJyk7XG4gICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIGFwaV9rZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgZm9ybWF0OiAnanNvbidcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xlYW5QYXJhbXMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocGFyYW1zKS5maWx0ZXIoKFtfLCB2XSkgPT4gISF2KSk7XG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoY2xlYW5QYXJhbXMpO1xuICAgICAgICBpZiAoc2lnbmVkKSB7XG4gICAgICAgICAgICAvLyBvcmRlciBjbGVhblBhcmFtcyBhbHBoYWJldGljYWxseSBieSBrZXlcbiAgICAgICAgICAgIGNvbnN0IG9yZGVyZWRQYXJhbXMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY2xlYW5QYXJhbXMpLnNvcnQoKFthXSwgW2JdKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IE9iamVjdC5lbnRyaWVzKG9yZGVyZWRQYXJhbXMpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW2tdKSA9PiBrICE9PSAnZm9ybWF0JylcbiAgICAgICAgICAgICAgICAubWFwKChbaywgdl0pID0+IGAke2t9JHt2fWApXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpICsgdGhpcy5hcGlTZWNyZXQ7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWRTaWduYXR1cmUgPSBjcnlwdG9cbiAgICAgICAgICAgICAgICAuY3JlYXRlSGFzaCgnbWQ1JylcbiAgICAgICAgICAgICAgICAudXBkYXRlKHNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCdoZXgnKTtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5zZXQoJ2FwaV9zaWcnLCBoYXNoZWRTaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGludGVybmFsRGF0YSA9IHt9O1xuICAgICAgICB0aGlzLm9uUmVxdWVzdFN0YXJ0ZWQobWV0aG9kLCBjbGVhblBhcmFtcywgaW50ZXJuYWxEYXRhKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB3cml0ZVxuICAgICAgICAgICAgPyBhd2FpdCBmZXRjaChgJHt0aGlzLmFwaVVybH0vP2Zvcm1hdD1qc29uYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBxdWVyeVN0cmluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogYXdhaXQgZmV0Y2goYCR7dGhpcy5hcGlVcmx9PyR7cXVlcnlTdHJpbmd9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHRoaXMub25SZXF1ZXN0RmluaXNoZWQobWV0aG9kLCBjbGVhblBhcmFtcywgaW50ZXJuYWxEYXRhLCBkYXRhKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaylcbiAgICAgICAgICAgIHRocm93IG5ldyBMYXN0Zm1FcnJvcihkYXRhKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufVxuXG5leHBvcnQgeyBMYXN0Q2xpZW50IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/@musicorum+lastfm@0.3.1/node_modules/@musicorum/lastfm/dist/LastClient.js\n");

/***/ })

};
;