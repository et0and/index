/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/aframe-forcegraph-component@3.0.8_three@0.163.0";
exports.ids = ["vendor-chunks/aframe-forcegraph-component@3.0.8_three@0.163.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/aframe-forcegraph-component@3.0.8_three@0.163.0/node_modules/aframe-forcegraph-component/index.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/aframe-forcegraph-component@3.0.8_three@0.163.0/node_modules/aframe-forcegraph-component/index.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* global AFRAME */\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nlet accessorFn = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/.pnpm/accessor-fn@1.5.0/node_modules/accessor-fn/dist/accessor-fn.mjs\");\nif ('default' in accessorFn) {\n  // unwrap default export\n  accessorFn = accessorFn.default;\n}\n\nlet ThreeForceGraph = __webpack_require__(/*! three-forcegraph */ \"(ssr)/./node_modules/.pnpm/three-forcegraph@1.41.13_three@0.163.0/node_modules/three-forcegraph/dist/three-forcegraph.mjs\");\nif ('default' in ThreeForceGraph) {\n  // unwrap default export\n  ThreeForceGraph = ThreeForceGraph.default;\n}\n\nconst parseJson = function (prop) {\n  return (typeof prop === 'string')\n    ? JSON.parse(prop)\n    : prop; // already parsed\n};\n\nconst parseFn = function (prop) {\n  if (typeof prop === 'function') return prop; // already a function\n  const geval = eval; // Avoid using eval directly https://github.com/rollup/rollup/wiki/Troubleshooting#avoiding-eval\n  try {\n    const evalled = geval('(' + prop + ')');\n    return evalled;\n  } catch (e) {} // Can't eval, not a function\n  return null;\n};\n\nconst parseAccessor = function (prop) {\n  if (!isNaN(parseFloat(prop))) { return parseFloat(prop); } // parse numbers\n  if (parseFn(prop)) { return parseFn(prop); } // parse functions\n  return prop; // strings\n};\n\n/**\n * 3D Force-Directed Graph component for A-Frame.\n */\nAFRAME.registerComponent('forcegraph', {\n  schema: {\n    jsonUrl: { type: 'string', default: '' },\n    nodes: { parse: parseJson, default: [] },\n    links: { parse: parseJson, default: [] },\n    numDimensions: { type: 'number', default: 3 },\n    dagMode: { type: 'string', default: '' },\n    dagLevelDistance: { type: 'number', default: 0 },\n    dagNodeFilter: { parse: parseFn, default: function() { return true; }},\n    onDagError: { parse: parseFn, default: undefined },\n    nodeRelSize: { type: 'number', default: 4 }, // volume per val unit\n    nodeId: { type: 'string', default: 'id' },\n    nodeVal: { parse: parseAccessor, default: 'val' },\n    nodeResolution: { type: 'number', default: 8 }, // how many slice segments in the sphere's circumference\n    nodeVisibility: { parse: parseAccessor, default: true },\n    nodeColor: { parse: parseAccessor, default: 'color' },\n    nodeAutoColorBy: { parse: parseAccessor, default: '' }, // color nodes with the same field equally\n    nodeOpacity: { type: 'number', default: 0.75 },\n    nodeThreeObject: { parse: parseAccessor, default: null },\n    nodeThreeObjectExtend: { parse: parseAccessor, default: false },\n    linkSource: { type: 'string', default: 'source' },\n    linkTarget: { type: 'string', default: 'target' },\n    linkVisibility: { parse: parseAccessor, default: true },\n    linkColor: { parse: parseAccessor, default: 'color' },\n    linkAutoColorBy: { parse: parseAccessor, default: '' }, // color links with the same field equally\n    linkOpacity: { type: 'number', default: 0.2 },\n    linkWidth: { parse: parseAccessor, default: 0 },\n    linkResolution: { type: 'number', default: 6 }, // how many radial segments in each line cylinder's geometry\n    linkCurvature: { parse: parseAccessor, default: 0 },\n    linkCurveRotation: { parse: parseAccessor, default: 0 },\n    linkMaterial: { parse: parseAccessor, default: null },\n    linkThreeObject: { parse: parseAccessor, default: null },\n    linkThreeObjectExtend: { parse: parseAccessor, default: false },\n    linkPositionUpdate: { parse: parseFn, default: null },\n    linkDirectionalArrowLength: { parse: parseAccessor, default: 0 },\n    linkDirectionalArrowColor: { parse: parseAccessor, default: null },\n    linkDirectionalArrowRelPos: { parse: parseAccessor, default: 0.5 }, // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalArrowResolution: { type: 'number', default: 8 }, // how many slice segments in the arrow's conic circumference\n    linkDirectionalParticles: { parse: parseAccessor, default: 0 }, // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: { parse: parseAccessor, default: 0.01 }, // in link length ratio per frame\n    linkDirectionalParticleWidth: { parse: parseAccessor, default: 0.5 },\n    linkDirectionalParticleColor: { parse: parseAccessor, default: null },\n    linkDirectionalParticleResolution: { type: 'number', default: 4 }, // how many slice segments in the particle sphere's circumference\n    onNodeHover: { parse: parseFn, default: () => {} },\n    onLinkHover: { parse: parseFn, default: () => {} },\n    onNodeClick: { parse: parseFn, default: () => {} },\n    onLinkClick: { parse: parseFn, default: () => {} },\n    forceEngine: { type: 'string', default: 'd3' }, // 'd3' or 'ngraph'\n    d3AlphaMin: { type: 'number', default: 0 },\n    d3AlphaDecay: { type: 'number', default: 0.0228 },\n    d3VelocityDecay: { type: 'number', default: 0.4 },\n    ngraphPhysics: { parse: parseJson, default: null },\n    warmupTicks: { type: 'int', default: 0 }, // how many times to tick the force engine at init before starting to render\n    cooldownTicks: { type: 'int', default: 1e18 }, // Simulate infinity (int parser doesn't accept Infinity object)\n    cooldownTime: { type: 'int', default: 15000 }, // ms\n    onEngineTick: { parse: parseFn, default: function () {} },\n    onEngineStop: { parse: parseFn, default: function () {} }\n  },\n\n  // Bind component methods\n  getGraphBbox: function() {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    return this.forceGraph.getGraphBbox();\n  },\n  emitParticle: function () {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    const forceGraph = this.forceGraph;\n    const returnVal = forceGraph.emitParticle.apply(forceGraph, arguments);\n\n    return returnVal === forceGraph\n      ? this // return self, not the inner forcegraph component\n      : returnVal;\n  },\n\n  d3Force: function () {\n    if (!this.forceGraph) {\n      // Got here before component init -> initialize forceGraph\n      this.forceGraph = new ThreeForceGraph();\n    }\n\n    const forceGraph = this.forceGraph;\n    const returnVal = forceGraph.d3Force.apply(forceGraph, arguments);\n\n    return returnVal === forceGraph\n      ? this // return self, not the inner forcegraph component\n      : returnVal;\n  },\n\n  d3ReheatSimulation: function () {\n    this.forceGraph && this.forceGraph.d3ReheatSimulation();\n    return this;\n  },\n\n  refresh: function () {\n    this.forceGraph && this.forceGraph.refresh();\n    return this;\n  },\n\n  init: function () {\n    const state = this.state = {}; // Internal state\n\n    // Add info msg\n    state.infoEl = document.createElement('a-text');\n    state.infoEl.setAttribute('position', '0 -0.1 -1'); // Canvas center\n    state.infoEl.setAttribute('width', 1);\n    state.infoEl.setAttribute('align', 'center');\n    state.infoEl.setAttribute('color', 'lavender');\n\n    // Get camera dom element and attach fixed view elements to camera\n    const cameraEl = document.querySelector('a-entity[camera], a-camera');\n    cameraEl.appendChild(state.infoEl);\n\n    // Keep reference to Three camera object\n    state.cameraObj = cameraEl.object3D.children\n      .filter(function (child) { return child.type === 'PerspectiveCamera'; })[0];\n\n    // On camera switch\n    this.el.sceneEl.addEventListener('camera-set-active', function (evt) {\n      // Switch camera reference\n      state.cameraObj = evt.detail.cameraEl.components.camera.camera;\n    });\n\n    // setup FG object\n    if (!this.forceGraph) this.forceGraph = new ThreeForceGraph(); // initialize forceGraph if it doesn't exist yet\n    this.forceGraph\n      .onFinishUpdate(() => this.el.setObject3D('forcegraphGroup', this.forceGraph)) // Bind forcegraph to elem\n      .onLoading(() => state.infoEl.setAttribute('value', 'Loading...')) // Add loading msg\n      .onFinishLoading(() => state.infoEl.setAttribute('value', ''));\n\n    // prefer raycaster events over mouseenter/mouseleave because they expose immediately available intersection data via detail.getIntersection()\n    this.el.addEventListener('raycaster-intersected', ev => state.hoverDetail = ev.detail);\n    this.el.addEventListener('raycaster-intersected-cleared', ev => state.hoverDetail = ev.detail);\n\n    this.el.addEventListener('click', () =>\n      state.hoverObj && this.data['on' + (state.hoverObj.__graphObjType === 'node' ? 'Node' : 'Link') + 'Click'](state.hoverObj.__data)\n    );\n  },\n\n  remove: function () {\n    // Clean-up elems\n    this.state.infoEl.remove();\n    this.el.removeObject3D('forcegraphGroup');\n  },\n\n  update: function (oldData) {\n    const comp = this;\n    const elData = this.data;\n    const diff = AFRAME.utils.diff(elData, oldData);\n\n    const fgProps = [\n      'jsonUrl',\n      'numDimensions',\n      'dagMode',\n      'dagLevelDistance',\n      'dagNodeFilter',\n      'onDagError',\n      'nodeRelSize',\n      'nodeId',\n      'nodeVal',\n      'nodeResolution',\n      'nodeVisibility',\n      'nodeColor',\n      'nodeAutoColorBy',\n      'nodeOpacity',\n      'nodeThreeObject',\n      'nodeThreeObjectExtend',\n      'linkSource',\n      'linkTarget',\n      'linkVisibility',\n      'linkColor',\n      'linkAutoColorBy',\n      'linkOpacity',\n      'linkWidth',\n      'linkResolution',\n      'linkCurvature',\n      'linkCurveRotation',\n      'linkMaterial',\n      'linkThreeObject',\n      'linkThreeObjectExtend',\n      'linkPositionUpdate',\n      'linkDirectionalArrowLength',\n      'linkDirectionalArrowColor',\n      'linkDirectionalArrowRelPos',\n      'linkDirectionalArrowResolution',\n      'linkDirectionalParticles',\n      'linkDirectionalParticleSpeed',\n      'linkDirectionalParticleWidth',\n      'linkDirectionalParticleColor',\n      'linkDirectionalParticleResolution',\n      'forceEngine',\n      'd3AlphaMin',\n      'd3AphaDecay',\n      'd3VelocityDecay',\n      'ngraphPhysics',\n      'warmupTicks',\n      'cooldownTicks',\n      'cooldownTime',\n      'onEngineTick',\n      'onEngineStop'\n    ];\n\n    fgProps\n      .filter(function (p) { return p in diff; })\n      .forEach(function (p) { comp.forceGraph[p](elData[p] !== '' ? elData[p] : null); }); // Convert blank values into nulls\n\n    if ('nodes' in diff || 'links' in diff) {\n      comp.forceGraph.graphData({\n        nodes: elData.nodes,\n        links: elData.links\n      });\n    }\n  },\n\n  tick: function (t, td) {\n    const state = this.state;\n    const props = this.data;\n\n    // Update hover (intersected) object\n    const intersection = state.hoverDetail\n      ? state.hoverDetail.getIntersection\n        ? state.hoverDetail.getIntersection(this.el) // available in raycaster-intersected events\n        : state.hoverDetail.intersection || undefined // available in mouseenter/mouseleave events (with delayed update)\n      : undefined;\n\n    // Note:\n    // Unfortunately we only have access to the intersected object closer to the camera (1st element in the raycaster intersectObjects result),\n    // there is no \".getIntersections()\" method available in the event details. Therefore, we can't prioritize hover on nodes over links, or even exclude\n    // objects that are neither nodes or links. This makes the interaction a bit erratic if nodes have a lot of links in front.\n    // Configuring the raycaster.params.Line.threshold might help with this somewhat, but that config is also not available via the a-frame raycaster component.\n\n    // recurse up until forcegraph obj is found\n    let topObject = intersection ? intersection.object : undefined;\n    while (topObject && !topObject.hasOwnProperty('__graphObjType'))\n      topObject = topObject.parent;\n\n    if (topObject !== state.hoverObj) {\n      const prevObjType = state.hoverObj ? state.hoverObj.__graphObjType : null;\n      const prevObjData = state.hoverObj ? state.hoverObj.__data : null;\n      const objType = topObject ? topObject.__graphObjType : null;\n      const objData = topObject ? topObject.__data : null;\n\n      if (prevObjType && prevObjType !== objType) {\n        // Hover out\n        props['on' + (prevObjType === 'node' ? 'Node' : 'Link') + 'Hover'](null, prevObjData);\n      }\n      if (objType) {\n        // Hover in\n        props['on' + (objType === 'node' ? 'Node' : 'Link') + 'Hover'](objData, prevObjType === objType ? prevObjData : null);\n      }\n\n      state.hoverObj = topObject;\n    }\n\n    // Run force-graph ticker\n    this.forceGraph.tickFrame();\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWZyYW1lLWZvcmNlZ3JhcGgtY29tcG9uZW50QDMuMC44X3RocmVlQDAuMTYzLjAvbm9kZV9tb2R1bGVzL2FmcmFtZS1mb3JjZWdyYXBoLWNvbXBvbmVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsK0dBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsbUpBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLCtDQUErQztBQUMvQyxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFhO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdELHVCQUF1Qix3QkFBd0I7QUFDL0MsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QyxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLCtCQUErQjtBQUM1QyxxQkFBcUIsNEJBQTRCO0FBQ2pELGVBQWUsNkJBQTZCO0FBQzVDLHdCQUF3Qiw0QkFBNEI7QUFDcEQscUJBQXFCLHNDQUFzQyxlQUFlO0FBQzFFLGtCQUFrQixvQ0FBb0M7QUFDdEQsbUJBQW1CLDRCQUE0QjtBQUMvQyxjQUFjLCtCQUErQjtBQUM3QyxlQUFlLHNDQUFzQztBQUNyRCxzQkFBc0IsNEJBQTRCO0FBQ2xELHNCQUFzQixxQ0FBcUM7QUFDM0QsaUJBQWlCLHdDQUF3QztBQUN6RCx1QkFBdUIsbUNBQW1DO0FBQzFELG1CQUFtQiwrQkFBK0I7QUFDbEQsdUJBQXVCLHFDQUFxQztBQUM1RCw2QkFBNkIsc0NBQXNDO0FBQ25FLGtCQUFrQixtQ0FBbUM7QUFDckQsa0JBQWtCLG1DQUFtQztBQUNyRCxzQkFBc0IscUNBQXFDO0FBQzNELGlCQUFpQix3Q0FBd0M7QUFDekQsdUJBQXVCLG1DQUFtQztBQUMxRCxtQkFBbUIsOEJBQThCO0FBQ2pELGlCQUFpQixrQ0FBa0M7QUFDbkQsc0JBQXNCLDRCQUE0QjtBQUNsRCxxQkFBcUIsa0NBQWtDO0FBQ3ZELHlCQUF5QixrQ0FBa0M7QUFDM0Qsb0JBQW9CLHFDQUFxQztBQUN6RCx1QkFBdUIscUNBQXFDO0FBQzVELDZCQUE2QixzQ0FBc0M7QUFDbkUsMEJBQTBCLCtCQUErQjtBQUN6RCxrQ0FBa0Msa0NBQWtDO0FBQ3BFLGlDQUFpQyxxQ0FBcUM7QUFDdEUsa0NBQWtDLG9DQUFvQztBQUN0RSxzQ0FBc0MsNEJBQTRCO0FBQ2xFLGdDQUFnQyxrQ0FBa0M7QUFDbEUsb0NBQW9DLHFDQUFxQztBQUN6RSxvQ0FBb0Msb0NBQW9DO0FBQ3hFLG9DQUFvQyxxQ0FBcUM7QUFDekUseUNBQXlDLDRCQUE0QjtBQUNyRSxtQkFBbUIsbUNBQW1DO0FBQ3RELG1CQUFtQixtQ0FBbUM7QUFDdEQsbUJBQW1CLG1DQUFtQztBQUN0RCxtQkFBbUIsbUNBQW1DO0FBQ3RELG1CQUFtQiwrQkFBK0I7QUFDbEQsa0JBQWtCLDRCQUE0QjtBQUM5QyxvQkFBb0IsaUNBQWlDO0FBQ3JELHVCQUF1Qiw4QkFBOEI7QUFDckQscUJBQXFCLGlDQUFpQztBQUN0RCxtQkFBbUIseUJBQXlCO0FBQzVDLHFCQUFxQiw0QkFBNEI7QUFDakQsb0JBQW9CLDZCQUE2QjtBQUNqRCxvQkFBb0IseUNBQXlDO0FBQzdELG9CQUFvQjtBQUNwQixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0Qzs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hELDhCQUE4QiwwREFBMEQsR0FBRzs7QUFFM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmFwaGFlbHNhbGFqYS8uL25vZGVfbW9kdWxlcy8ucG5wbS9hZnJhbWUtZm9yY2VncmFwaC1jb21wb25lbnRAMy4wLjhfdGhyZWVAMC4xNjMuMC9ub2RlX21vZHVsZXMvYWZyYW1lLWZvcmNlZ3JhcGgtY29tcG9uZW50L2luZGV4LmpzP2U5OGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIEFGUkFNRSAqL1xuXG5pZiAodHlwZW9mIEFGUkFNRSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb21wb25lbnQgYXR0ZW1wdGVkIHRvIHJlZ2lzdGVyIGJlZm9yZSBBRlJBTUUgd2FzIGF2YWlsYWJsZS4nKTtcbn1cblxubGV0IGFjY2Vzc29yRm4gPSByZXF1aXJlKCdhY2Nlc3Nvci1mbicpO1xuaWYgKCdkZWZhdWx0JyBpbiBhY2Nlc3NvckZuKSB7XG4gIC8vIHVud3JhcCBkZWZhdWx0IGV4cG9ydFxuICBhY2Nlc3NvckZuID0gYWNjZXNzb3JGbi5kZWZhdWx0O1xufVxuXG5sZXQgVGhyZWVGb3JjZUdyYXBoID0gcmVxdWlyZSgndGhyZWUtZm9yY2VncmFwaCcpO1xuaWYgKCdkZWZhdWx0JyBpbiBUaHJlZUZvcmNlR3JhcGgpIHtcbiAgLy8gdW53cmFwIGRlZmF1bHQgZXhwb3J0XG4gIFRocmVlRm9yY2VHcmFwaCA9IFRocmVlRm9yY2VHcmFwaC5kZWZhdWx0O1xufVxuXG5jb25zdCBwYXJzZUpzb24gPSBmdW5jdGlvbiAocHJvcCkge1xuICByZXR1cm4gKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJylcbiAgICA/IEpTT04ucGFyc2UocHJvcClcbiAgICA6IHByb3A7IC8vIGFscmVhZHkgcGFyc2VkXG59O1xuXG5jb25zdCBwYXJzZUZuID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgaWYgKHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nKSByZXR1cm4gcHJvcDsgLy8gYWxyZWFkeSBhIGZ1bmN0aW9uXG4gIGNvbnN0IGdldmFsID0gZXZhbDsgLy8gQXZvaWQgdXNpbmcgZXZhbCBkaXJlY3RseSBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC93aWtpL1Ryb3VibGVzaG9vdGluZyNhdm9pZGluZy1ldmFsXG4gIHRyeSB7XG4gICAgY29uc3QgZXZhbGxlZCA9IGdldmFsKCcoJyArIHByb3AgKyAnKScpO1xuICAgIHJldHVybiBldmFsbGVkO1xuICB9IGNhdGNoIChlKSB7fSAvLyBDYW4ndCBldmFsLCBub3QgYSBmdW5jdGlvblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHBhcnNlQWNjZXNzb3IgPSBmdW5jdGlvbiAocHJvcCkge1xuICBpZiAoIWlzTmFOKHBhcnNlRmxvYXQocHJvcCkpKSB7IHJldHVybiBwYXJzZUZsb2F0KHByb3ApOyB9IC8vIHBhcnNlIG51bWJlcnNcbiAgaWYgKHBhcnNlRm4ocHJvcCkpIHsgcmV0dXJuIHBhcnNlRm4ocHJvcCk7IH0gLy8gcGFyc2UgZnVuY3Rpb25zXG4gIHJldHVybiBwcm9wOyAvLyBzdHJpbmdzXG59O1xuXG4vKipcbiAqIDNEIEZvcmNlLURpcmVjdGVkIEdyYXBoIGNvbXBvbmVudCBmb3IgQS1GcmFtZS5cbiAqL1xuQUZSQU1FLnJlZ2lzdGVyQ29tcG9uZW50KCdmb3JjZWdyYXBoJywge1xuICBzY2hlbWE6IHtcbiAgICBqc29uVXJsOiB7IHR5cGU6ICdzdHJpbmcnLCBkZWZhdWx0OiAnJyB9LFxuICAgIG5vZGVzOiB7IHBhcnNlOiBwYXJzZUpzb24sIGRlZmF1bHQ6IFtdIH0sXG4gICAgbGlua3M6IHsgcGFyc2U6IHBhcnNlSnNvbiwgZGVmYXVsdDogW10gfSxcbiAgICBudW1EaW1lbnNpb25zOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAzIH0sXG4gICAgZGFnTW9kZTogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJycgfSxcbiAgICBkYWdMZXZlbERpc3RhbmNlOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwIH0sXG4gICAgZGFnTm9kZUZpbHRlcjogeyBwYXJzZTogcGFyc2VGbiwgZGVmYXVsdDogZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9fSxcbiAgICBvbkRhZ0Vycm9yOiB7IHBhcnNlOiBwYXJzZUZuLCBkZWZhdWx0OiB1bmRlZmluZWQgfSxcbiAgICBub2RlUmVsU2l6ZTogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogNCB9LCAvLyB2b2x1bWUgcGVyIHZhbCB1bml0XG4gICAgbm9kZUlkOiB7IHR5cGU6ICdzdHJpbmcnLCBkZWZhdWx0OiAnaWQnIH0sXG4gICAgbm9kZVZhbDogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogJ3ZhbCcgfSxcbiAgICBub2RlUmVzb2x1dGlvbjogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogOCB9LCAvLyBob3cgbWFueSBzbGljZSBzZWdtZW50cyBpbiB0aGUgc3BoZXJlJ3MgY2lyY3VtZmVyZW5jZVxuICAgIG5vZGVWaXNpYmlsaXR5OiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiB0cnVlIH0sXG4gICAgbm9kZUNvbG9yOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAnY29sb3InIH0sXG4gICAgbm9kZUF1dG9Db2xvckJ5OiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAnJyB9LCAvLyBjb2xvciBub2RlcyB3aXRoIHRoZSBzYW1lIGZpZWxkIGVxdWFsbHlcbiAgICBub2RlT3BhY2l0eTogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMC43NSB9LFxuICAgIG5vZGVUaHJlZU9iamVjdDogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogbnVsbCB9LFxuICAgIG5vZGVUaHJlZU9iamVjdEV4dGVuZDogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICBsaW5rU291cmNlOiB7IHR5cGU6ICdzdHJpbmcnLCBkZWZhdWx0OiAnc291cmNlJyB9LFxuICAgIGxpbmtUYXJnZXQ6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICd0YXJnZXQnIH0sXG4gICAgbGlua1Zpc2liaWxpdHk6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IHRydWUgfSxcbiAgICBsaW5rQ29sb3I6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6ICdjb2xvcicgfSxcbiAgICBsaW5rQXV0b0NvbG9yQnk6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6ICcnIH0sIC8vIGNvbG9yIGxpbmtzIHdpdGggdGhlIHNhbWUgZmllbGQgZXF1YWxseVxuICAgIGxpbmtPcGFjaXR5OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwLjIgfSxcbiAgICBsaW5rV2lkdGg6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IDAgfSxcbiAgICBsaW5rUmVzb2x1dGlvbjogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogNiB9LCAvLyBob3cgbWFueSByYWRpYWwgc2VnbWVudHMgaW4gZWFjaCBsaW5lIGN5bGluZGVyJ3MgZ2VvbWV0cnlcbiAgICBsaW5rQ3VydmF0dXJlOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAwIH0sXG4gICAgbGlua0N1cnZlUm90YXRpb246IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IDAgfSxcbiAgICBsaW5rTWF0ZXJpYWw6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IG51bGwgfSxcbiAgICBsaW5rVGhyZWVPYmplY3Q6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IG51bGwgfSxcbiAgICBsaW5rVGhyZWVPYmplY3RFeHRlbmQ6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgbGlua1Bvc2l0aW9uVXBkYXRlOiB7IHBhcnNlOiBwYXJzZUZuLCBkZWZhdWx0OiBudWxsIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGg6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IDAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiBudWxsIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3M6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IDAuNSB9LCAvLyB2YWx1ZSBiZXR3ZWVuIDA8PjEgaW5kaWNhdGluZyB0aGUgcmVsYXRpdmUgcG9zIGFsb25nIHRoZSAoZXhwb3NlZCkgbGluZVxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93UmVzb2x1dGlvbjogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogOCB9LCAvLyBob3cgbWFueSBzbGljZSBzZWdtZW50cyBpbiB0aGUgYXJyb3cncyBjb25pYyBjaXJjdW1mZXJlbmNlXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVzOiB7IHBhcnNlOiBwYXJzZUFjY2Vzc29yLCBkZWZhdWx0OiAwIH0sIC8vIGFuaW1hdGUgcGhvdG9ucyB0cmF2ZWxsaW5nIGluIHRoZSBsaW5rIGRpcmVjdGlvblxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlU3BlZWQ6IHsgcGFyc2U6IHBhcnNlQWNjZXNzb3IsIGRlZmF1bHQ6IDAuMDEgfSwgLy8gaW4gbGluayBsZW5ndGggcmF0aW8gcGVyIGZyYW1lXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aDogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogMC41IH0sXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvcjogeyBwYXJzZTogcGFyc2VBY2Nlc3NvciwgZGVmYXVsdDogbnVsbCB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlUmVzb2x1dGlvbjogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogNCB9LCAvLyBob3cgbWFueSBzbGljZSBzZWdtZW50cyBpbiB0aGUgcGFydGljbGUgc3BoZXJlJ3MgY2lyY3VtZmVyZW5jZVxuICAgIG9uTm9kZUhvdmVyOiB7IHBhcnNlOiBwYXJzZUZuLCBkZWZhdWx0OiAoKSA9PiB7fSB9LFxuICAgIG9uTGlua0hvdmVyOiB7IHBhcnNlOiBwYXJzZUZuLCBkZWZhdWx0OiAoKSA9PiB7fSB9LFxuICAgIG9uTm9kZUNsaWNrOiB7IHBhcnNlOiBwYXJzZUZuLCBkZWZhdWx0OiAoKSA9PiB7fSB9LFxuICAgIG9uTGlua0NsaWNrOiB7IHBhcnNlOiBwYXJzZUZuLCBkZWZhdWx0OiAoKSA9PiB7fSB9LFxuICAgIGZvcmNlRW5naW5lOiB7IHR5cGU6ICdzdHJpbmcnLCBkZWZhdWx0OiAnZDMnIH0sIC8vICdkMycgb3IgJ25ncmFwaCdcbiAgICBkM0FscGhhTWluOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwIH0sXG4gICAgZDNBbHBoYURlY2F5OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwLjAyMjggfSxcbiAgICBkM1ZlbG9jaXR5RGVjYXk6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDAuNCB9LFxuICAgIG5ncmFwaFBoeXNpY3M6IHsgcGFyc2U6IHBhcnNlSnNvbiwgZGVmYXVsdDogbnVsbCB9LFxuICAgIHdhcm11cFRpY2tzOiB7IHR5cGU6ICdpbnQnLCBkZWZhdWx0OiAwIH0sIC8vIGhvdyBtYW55IHRpbWVzIHRvIHRpY2sgdGhlIGZvcmNlIGVuZ2luZSBhdCBpbml0IGJlZm9yZSBzdGFydGluZyB0byByZW5kZXJcbiAgICBjb29sZG93blRpY2tzOiB7IHR5cGU6ICdpbnQnLCBkZWZhdWx0OiAxZTE4IH0sIC8vIFNpbXVsYXRlIGluZmluaXR5IChpbnQgcGFyc2VyIGRvZXNuJ3QgYWNjZXB0IEluZmluaXR5IG9iamVjdClcbiAgICBjb29sZG93blRpbWU6IHsgdHlwZTogJ2ludCcsIGRlZmF1bHQ6IDE1MDAwIH0sIC8vIG1zXG4gICAgb25FbmdpbmVUaWNrOiB7IHBhcnNlOiBwYXJzZUZuLCBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7fSB9LFxuICAgIG9uRW5naW5lU3RvcDogeyBwYXJzZTogcGFyc2VGbiwgZGVmYXVsdDogZnVuY3Rpb24gKCkge30gfVxuICB9LFxuXG4gIC8vIEJpbmQgY29tcG9uZW50IG1ldGhvZHNcbiAgZ2V0R3JhcGhCYm94OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZm9yY2VHcmFwaCkge1xuICAgICAgLy8gR290IGhlcmUgYmVmb3JlIGNvbXBvbmVudCBpbml0IC0+IGluaXRpYWxpemUgZm9yY2VHcmFwaFxuICAgICAgdGhpcy5mb3JjZUdyYXBoID0gbmV3IFRocmVlRm9yY2VHcmFwaCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZvcmNlR3JhcGguZ2V0R3JhcGhCYm94KCk7XG4gIH0sXG4gIGVtaXRQYXJ0aWNsZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5mb3JjZUdyYXBoKSB7XG4gICAgICAvLyBHb3QgaGVyZSBiZWZvcmUgY29tcG9uZW50IGluaXQgLT4gaW5pdGlhbGl6ZSBmb3JjZUdyYXBoXG4gICAgICB0aGlzLmZvcmNlR3JhcGggPSBuZXcgVGhyZWVGb3JjZUdyYXBoKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9yY2VHcmFwaCA9IHRoaXMuZm9yY2VHcmFwaDtcbiAgICBjb25zdCByZXR1cm5WYWwgPSBmb3JjZUdyYXBoLmVtaXRQYXJ0aWNsZS5hcHBseShmb3JjZUdyYXBoLCBhcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIHJldHVyblZhbCA9PT0gZm9yY2VHcmFwaFxuICAgICAgPyB0aGlzIC8vIHJldHVybiBzZWxmLCBub3QgdGhlIGlubmVyIGZvcmNlZ3JhcGggY29tcG9uZW50XG4gICAgICA6IHJldHVyblZhbDtcbiAgfSxcblxuICBkM0ZvcmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmZvcmNlR3JhcGgpIHtcbiAgICAgIC8vIEdvdCBoZXJlIGJlZm9yZSBjb21wb25lbnQgaW5pdCAtPiBpbml0aWFsaXplIGZvcmNlR3JhcGhcbiAgICAgIHRoaXMuZm9yY2VHcmFwaCA9IG5ldyBUaHJlZUZvcmNlR3JhcGgoKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JjZUdyYXBoID0gdGhpcy5mb3JjZUdyYXBoO1xuICAgIGNvbnN0IHJldHVyblZhbCA9IGZvcmNlR3JhcGguZDNGb3JjZS5hcHBseShmb3JjZUdyYXBoLCBhcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIHJldHVyblZhbCA9PT0gZm9yY2VHcmFwaFxuICAgICAgPyB0aGlzIC8vIHJldHVybiBzZWxmLCBub3QgdGhlIGlubmVyIGZvcmNlZ3JhcGggY29tcG9uZW50XG4gICAgICA6IHJldHVyblZhbDtcbiAgfSxcblxuICBkM1JlaGVhdFNpbXVsYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZvcmNlR3JhcGggJiYgdGhpcy5mb3JjZUdyYXBoLmQzUmVoZWF0U2ltdWxhdGlvbigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZvcmNlR3JhcGggJiYgdGhpcy5mb3JjZUdyYXBoLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlID0ge307IC8vIEludGVybmFsIHN0YXRlXG5cbiAgICAvLyBBZGQgaW5mbyBtc2dcbiAgICBzdGF0ZS5pbmZvRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhLXRleHQnKTtcbiAgICBzdGF0ZS5pbmZvRWwuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsICcwIC0wLjEgLTEnKTsgLy8gQ2FudmFzIGNlbnRlclxuICAgIHN0YXRlLmluZm9FbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMSk7XG4gICAgc3RhdGUuaW5mb0VsLnNldEF0dHJpYnV0ZSgnYWxpZ24nLCAnY2VudGVyJyk7XG4gICAgc3RhdGUuaW5mb0VsLnNldEF0dHJpYnV0ZSgnY29sb3InLCAnbGF2ZW5kZXInKTtcblxuICAgIC8vIEdldCBjYW1lcmEgZG9tIGVsZW1lbnQgYW5kIGF0dGFjaCBmaXhlZCB2aWV3IGVsZW1lbnRzIHRvIGNhbWVyYVxuICAgIGNvbnN0IGNhbWVyYUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYS1lbnRpdHlbY2FtZXJhXSwgYS1jYW1lcmEnKTtcbiAgICBjYW1lcmFFbC5hcHBlbmRDaGlsZChzdGF0ZS5pbmZvRWwpO1xuXG4gICAgLy8gS2VlcCByZWZlcmVuY2UgdG8gVGhyZWUgY2FtZXJhIG9iamVjdFxuICAgIHN0YXRlLmNhbWVyYU9iaiA9IGNhbWVyYUVsLm9iamVjdDNELmNoaWxkcmVuXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudHlwZSA9PT0gJ1BlcnNwZWN0aXZlQ2FtZXJhJzsgfSlbMF07XG5cbiAgICAvLyBPbiBjYW1lcmEgc3dpdGNoXG4gICAgdGhpcy5lbC5zY2VuZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbWVyYS1zZXQtYWN0aXZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgLy8gU3dpdGNoIGNhbWVyYSByZWZlcmVuY2VcbiAgICAgIHN0YXRlLmNhbWVyYU9iaiA9IGV2dC5kZXRhaWwuY2FtZXJhRWwuY29tcG9uZW50cy5jYW1lcmEuY2FtZXJhO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0dXAgRkcgb2JqZWN0XG4gICAgaWYgKCF0aGlzLmZvcmNlR3JhcGgpIHRoaXMuZm9yY2VHcmFwaCA9IG5ldyBUaHJlZUZvcmNlR3JhcGgoKTsgLy8gaW5pdGlhbGl6ZSBmb3JjZUdyYXBoIGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0XG4gICAgdGhpcy5mb3JjZUdyYXBoXG4gICAgICAub25GaW5pc2hVcGRhdGUoKCkgPT4gdGhpcy5lbC5zZXRPYmplY3QzRCgnZm9yY2VncmFwaEdyb3VwJywgdGhpcy5mb3JjZUdyYXBoKSkgLy8gQmluZCBmb3JjZWdyYXBoIHRvIGVsZW1cbiAgICAgIC5vbkxvYWRpbmcoKCkgPT4gc3RhdGUuaW5mb0VsLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnTG9hZGluZy4uLicpKSAvLyBBZGQgbG9hZGluZyBtc2dcbiAgICAgIC5vbkZpbmlzaExvYWRpbmcoKCkgPT4gc3RhdGUuaW5mb0VsLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJykpO1xuXG4gICAgLy8gcHJlZmVyIHJheWNhc3RlciBldmVudHMgb3ZlciBtb3VzZWVudGVyL21vdXNlbGVhdmUgYmVjYXVzZSB0aGV5IGV4cG9zZSBpbW1lZGlhdGVseSBhdmFpbGFibGUgaW50ZXJzZWN0aW9uIGRhdGEgdmlhIGRldGFpbC5nZXRJbnRlcnNlY3Rpb24oKVxuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigncmF5Y2FzdGVyLWludGVyc2VjdGVkJywgZXYgPT4gc3RhdGUuaG92ZXJEZXRhaWwgPSBldi5kZXRhaWwpO1xuICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigncmF5Y2FzdGVyLWludGVyc2VjdGVkLWNsZWFyZWQnLCBldiA9PiBzdGF0ZS5ob3ZlckRldGFpbCA9IGV2LmRldGFpbCk7XG5cbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT5cbiAgICAgIHN0YXRlLmhvdmVyT2JqICYmIHRoaXMuZGF0YVsnb24nICsgKHN0YXRlLmhvdmVyT2JqLl9fZ3JhcGhPYmpUeXBlID09PSAnbm9kZScgPyAnTm9kZScgOiAnTGluaycpICsgJ0NsaWNrJ10oc3RhdGUuaG92ZXJPYmouX19kYXRhKVxuICAgICk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2xlYW4tdXAgZWxlbXNcbiAgICB0aGlzLnN0YXRlLmluZm9FbC5yZW1vdmUoKTtcbiAgICB0aGlzLmVsLnJlbW92ZU9iamVjdDNEKCdmb3JjZWdyYXBoR3JvdXAnKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIChvbGREYXRhKSB7XG4gICAgY29uc3QgY29tcCA9IHRoaXM7XG4gICAgY29uc3QgZWxEYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGRpZmYgPSBBRlJBTUUudXRpbHMuZGlmZihlbERhdGEsIG9sZERhdGEpO1xuXG4gICAgY29uc3QgZmdQcm9wcyA9IFtcbiAgICAgICdqc29uVXJsJyxcbiAgICAgICdudW1EaW1lbnNpb25zJyxcbiAgICAgICdkYWdNb2RlJyxcbiAgICAgICdkYWdMZXZlbERpc3RhbmNlJyxcbiAgICAgICdkYWdOb2RlRmlsdGVyJyxcbiAgICAgICdvbkRhZ0Vycm9yJyxcbiAgICAgICdub2RlUmVsU2l6ZScsXG4gICAgICAnbm9kZUlkJyxcbiAgICAgICdub2RlVmFsJyxcbiAgICAgICdub2RlUmVzb2x1dGlvbicsXG4gICAgICAnbm9kZVZpc2liaWxpdHknLFxuICAgICAgJ25vZGVDb2xvcicsXG4gICAgICAnbm9kZUF1dG9Db2xvckJ5JyxcbiAgICAgICdub2RlT3BhY2l0eScsXG4gICAgICAnbm9kZVRocmVlT2JqZWN0JyxcbiAgICAgICdub2RlVGhyZWVPYmplY3RFeHRlbmQnLFxuICAgICAgJ2xpbmtTb3VyY2UnLFxuICAgICAgJ2xpbmtUYXJnZXQnLFxuICAgICAgJ2xpbmtWaXNpYmlsaXR5JyxcbiAgICAgICdsaW5rQ29sb3InLFxuICAgICAgJ2xpbmtBdXRvQ29sb3JCeScsXG4gICAgICAnbGlua09wYWNpdHknLFxuICAgICAgJ2xpbmtXaWR0aCcsXG4gICAgICAnbGlua1Jlc29sdXRpb24nLFxuICAgICAgJ2xpbmtDdXJ2YXR1cmUnLFxuICAgICAgJ2xpbmtDdXJ2ZVJvdGF0aW9uJyxcbiAgICAgICdsaW5rTWF0ZXJpYWwnLFxuICAgICAgJ2xpbmtUaHJlZU9iamVjdCcsXG4gICAgICAnbGlua1RocmVlT2JqZWN0RXh0ZW5kJyxcbiAgICAgICdsaW5rUG9zaXRpb25VcGRhdGUnLFxuICAgICAgJ2xpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoJyxcbiAgICAgICdsaW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yJyxcbiAgICAgICdsaW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvcycsXG4gICAgICAnbGlua0RpcmVjdGlvbmFsQXJyb3dSZXNvbHV0aW9uJyxcbiAgICAgICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMnLFxuICAgICAgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlU3BlZWQnLFxuICAgICAgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlV2lkdGgnLFxuICAgICAgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3InLFxuICAgICAgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlUmVzb2x1dGlvbicsXG4gICAgICAnZm9yY2VFbmdpbmUnLFxuICAgICAgJ2QzQWxwaGFNaW4nLFxuICAgICAgJ2QzQXBoYURlY2F5JyxcbiAgICAgICdkM1ZlbG9jaXR5RGVjYXknLFxuICAgICAgJ25ncmFwaFBoeXNpY3MnLFxuICAgICAgJ3dhcm11cFRpY2tzJyxcbiAgICAgICdjb29sZG93blRpY2tzJyxcbiAgICAgICdjb29sZG93blRpbWUnLFxuICAgICAgJ29uRW5naW5lVGljaycsXG4gICAgICAnb25FbmdpbmVTdG9wJ1xuICAgIF07XG5cbiAgICBmZ1Byb3BzXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwIGluIGRpZmY7IH0pXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbiAocCkgeyBjb21wLmZvcmNlR3JhcGhbcF0oZWxEYXRhW3BdICE9PSAnJyA/IGVsRGF0YVtwXSA6IG51bGwpOyB9KTsgLy8gQ29udmVydCBibGFuayB2YWx1ZXMgaW50byBudWxsc1xuXG4gICAgaWYgKCdub2RlcycgaW4gZGlmZiB8fCAnbGlua3MnIGluIGRpZmYpIHtcbiAgICAgIGNvbXAuZm9yY2VHcmFwaC5ncmFwaERhdGEoe1xuICAgICAgICBub2RlczogZWxEYXRhLm5vZGVzLFxuICAgICAgICBsaW5rczogZWxEYXRhLmxpbmtzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgdGljazogZnVuY3Rpb24gKHQsIHRkKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5kYXRhO1xuXG4gICAgLy8gVXBkYXRlIGhvdmVyIChpbnRlcnNlY3RlZCkgb2JqZWN0XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uID0gc3RhdGUuaG92ZXJEZXRhaWxcbiAgICAgID8gc3RhdGUuaG92ZXJEZXRhaWwuZ2V0SW50ZXJzZWN0aW9uXG4gICAgICAgID8gc3RhdGUuaG92ZXJEZXRhaWwuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZWwpIC8vIGF2YWlsYWJsZSBpbiByYXljYXN0ZXItaW50ZXJzZWN0ZWQgZXZlbnRzXG4gICAgICAgIDogc3RhdGUuaG92ZXJEZXRhaWwuaW50ZXJzZWN0aW9uIHx8IHVuZGVmaW5lZCAvLyBhdmFpbGFibGUgaW4gbW91c2VlbnRlci9tb3VzZWxlYXZlIGV2ZW50cyAod2l0aCBkZWxheWVkIHVwZGF0ZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gTm90ZTpcbiAgICAvLyBVbmZvcnR1bmF0ZWx5IHdlIG9ubHkgaGF2ZSBhY2Nlc3MgdG8gdGhlIGludGVyc2VjdGVkIG9iamVjdCBjbG9zZXIgdG8gdGhlIGNhbWVyYSAoMXN0IGVsZW1lbnQgaW4gdGhlIHJheWNhc3RlciBpbnRlcnNlY3RPYmplY3RzIHJlc3VsdCksXG4gICAgLy8gdGhlcmUgaXMgbm8gXCIuZ2V0SW50ZXJzZWN0aW9ucygpXCIgbWV0aG9kIGF2YWlsYWJsZSBpbiB0aGUgZXZlbnQgZGV0YWlscy4gVGhlcmVmb3JlLCB3ZSBjYW4ndCBwcmlvcml0aXplIGhvdmVyIG9uIG5vZGVzIG92ZXIgbGlua3MsIG9yIGV2ZW4gZXhjbHVkZVxuICAgIC8vIG9iamVjdHMgdGhhdCBhcmUgbmVpdGhlciBub2RlcyBvciBsaW5rcy4gVGhpcyBtYWtlcyB0aGUgaW50ZXJhY3Rpb24gYSBiaXQgZXJyYXRpYyBpZiBub2RlcyBoYXZlIGEgbG90IG9mIGxpbmtzIGluIGZyb250LlxuICAgIC8vIENvbmZpZ3VyaW5nIHRoZSByYXljYXN0ZXIucGFyYW1zLkxpbmUudGhyZXNob2xkIG1pZ2h0IGhlbHAgd2l0aCB0aGlzIHNvbWV3aGF0LCBidXQgdGhhdCBjb25maWcgaXMgYWxzbyBub3QgYXZhaWxhYmxlIHZpYSB0aGUgYS1mcmFtZSByYXljYXN0ZXIgY29tcG9uZW50LlxuXG4gICAgLy8gcmVjdXJzZSB1cCB1bnRpbCBmb3JjZWdyYXBoIG9iaiBpcyBmb3VuZFxuICAgIGxldCB0b3BPYmplY3QgPSBpbnRlcnNlY3Rpb24gPyBpbnRlcnNlY3Rpb24ub2JqZWN0IDogdW5kZWZpbmVkO1xuICAgIHdoaWxlICh0b3BPYmplY3QgJiYgIXRvcE9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnX19ncmFwaE9ialR5cGUnKSlcbiAgICAgIHRvcE9iamVjdCA9IHRvcE9iamVjdC5wYXJlbnQ7XG5cbiAgICBpZiAodG9wT2JqZWN0ICE9PSBzdGF0ZS5ob3Zlck9iaikge1xuICAgICAgY29uc3QgcHJldk9ialR5cGUgPSBzdGF0ZS5ob3Zlck9iaiA/IHN0YXRlLmhvdmVyT2JqLl9fZ3JhcGhPYmpUeXBlIDogbnVsbDtcbiAgICAgIGNvbnN0IHByZXZPYmpEYXRhID0gc3RhdGUuaG92ZXJPYmogPyBzdGF0ZS5ob3Zlck9iai5fX2RhdGEgOiBudWxsO1xuICAgICAgY29uc3Qgb2JqVHlwZSA9IHRvcE9iamVjdCA/IHRvcE9iamVjdC5fX2dyYXBoT2JqVHlwZSA6IG51bGw7XG4gICAgICBjb25zdCBvYmpEYXRhID0gdG9wT2JqZWN0ID8gdG9wT2JqZWN0Ll9fZGF0YSA6IG51bGw7XG5cbiAgICAgIGlmIChwcmV2T2JqVHlwZSAmJiBwcmV2T2JqVHlwZSAhPT0gb2JqVHlwZSkge1xuICAgICAgICAvLyBIb3ZlciBvdXRcbiAgICAgICAgcHJvcHNbJ29uJyArIChwcmV2T2JqVHlwZSA9PT0gJ25vZGUnID8gJ05vZGUnIDogJ0xpbmsnKSArICdIb3ZlciddKG51bGwsIHByZXZPYmpEYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmpUeXBlKSB7XG4gICAgICAgIC8vIEhvdmVyIGluXG4gICAgICAgIHByb3BzWydvbicgKyAob2JqVHlwZSA9PT0gJ25vZGUnID8gJ05vZGUnIDogJ0xpbmsnKSArICdIb3ZlciddKG9iakRhdGEsIHByZXZPYmpUeXBlID09PSBvYmpUeXBlID8gcHJldk9iakRhdGEgOiBudWxsKTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUuaG92ZXJPYmogPSB0b3BPYmplY3Q7XG4gICAgfVxuXG4gICAgLy8gUnVuIGZvcmNlLWdyYXBoIHRpY2tlclxuICAgIHRoaXMuZm9yY2VHcmFwaC50aWNrRnJhbWUoKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/aframe-forcegraph-component@3.0.8_three@0.163.0/node_modules/aframe-forcegraph-component/index.js\n");

/***/ })

};
;